<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Map</title>
  <link rel="icon" href="mark/icon.png" type="image/gif" sizes="16x16">
  <style>
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CSS CUSTOM PROPERTIES (Design Tokens)
       Centralized design system for consistent styling
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    :root {
      /* Color Palette*/
      --color-primary: #FF9800;
      --color-primary-light: #FFB74D;
      --color-primary-dark: #F57C00;
      --color-secondary: #2196F3;
      --color-secondary-light: #64B5F6;
      --color-success: #4CAF50;
      --color-success-light: #81C784;
      --color-danger: #f44336;
      --color-danger-light: #e57373;
      --color-warning: #FFC107;
      
      /* Neutral Colors*/
      --color-bg-dark: #000000;
      --color-bg-panel: rgba(20, 20, 20, 0.98);
      --color-bg-surface: rgba(30, 30, 30, 0.95);
      --color-bg-elevated: rgba(40, 40, 40, 0.9);
      --color-bg-input: rgba(40, 40, 40, 0.9);
      --color-bg-hover: rgba(50, 50, 50, 0.95);
      --color-bg-overlay: rgba(0, 0, 0, 0.8);
      
      /* Text Colors*/
      --color-text-primary: #ffffff;
      --color-text-secondary: #aaaaaa;
      --color-text-muted: #888888;
      --color-text-disabled: #666666;
      
      /* Border Colors*/
      --color-border: #555555;
      --color-border-light: #777777;
      --color-border-dark: #333333;
      --color-border-focus: var(--color-primary);
      
      /* Typography*/
      --font-family: Arial, sans-serif;
      --font-family-mono: 'Consolas', 'Monaco', monospace;
      --font-size-xs: 10px;
      --font-size-sm: 11px;
      --font-size-base: 13px;
      --font-size-md: 14px;
      --font-size-lg: 16px;
      --font-size-xl: 18px;
      --font-size-2xl: 20px;
      --line-height: 1.5;
      
      /* Spacing*/
      --spacing-xs: 4px;
      --spacing-sm: 8px;
      --spacing-md: 10px;
      --spacing-lg: 15px;
      --spacing-xl: 20px;
      --spacing-2xl: 30px;
      
      /* Border Radius*/
      --radius-sm: 3px;
      --radius-md: 4px;
      --radius-lg: 6px;
      --radius-xl: 8px;
      --radius-full: 50%;
      
      /* Shadows*/
      --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.5);
      --shadow-lg: 0 10px 50px rgba(0, 0, 0, 0.9);
      
      /* Transitions*/
      --transition-fast: 0.2s ease;
      --transition-normal: 0.3s ease;
      
      /* Z-Index Layers*/
      --z-marks: 100;
      --z-debug: 1000;
      --z-sidebar: 1999;
      --z-controls: 2000;
      --z-modal: 10000;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BASE STYLES & RESET
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    * {
      box-sizing: border-box;
    }
    
    body { 
      margin: 0; 
      overflow: hidden; 
      background: var(--color-bg-dark);
      font-family: var(--font-family);
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    input, textarea, select {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      font-family: inherit;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CANVAS STYLES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    canvas { 
      display: block; 
      cursor: grab; 
    }
    canvas:active { 
      cursor: grabbing; 
    }
    canvas.picking {
      cursor: crosshair !important;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       DEBUG PANEL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #debug {
      position: fixed;
      top: var(--spacing-md);
      right: var(--spacing-md);
      background: rgba(0, 0, 0, 0.7);
      color: var(--color-text-primary);
      padding: var(--spacing-sm) var(--spacing-md);
      font: 12px/1 var(--font-family-mono);
      border-radius: var(--radius-lg);
      z-index: var(--z-debug);
      pointer-events: none;
      min-width: 180px;
      text-align: right;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       VIEW TOGGLE BUTTONS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .view-toggles {
      position: fixed;
      top: 44px;
      right: var(--spacing-md);
      display: flex;
      gap: var(--spacing-sm);
      z-index: var(--z-debug);
    }
    
    .view-toggle-btn {
      background: rgba(0, 0, 0, 0.7);
      color: var(--color-text-primary);
      border: 2px solid var(--color-border);
      padding: var(--spacing-sm) 12px;
      font-size: 12px;
      line-height: 1;
      border-radius: var(--radius-lg);
      cursor: pointer;
      pointer-events: auto;
      transition: all var(--transition-fast);
      user-select: none;
    }
    .view-toggle-btn:hover {
      background: rgba(20, 20, 20, 0.9);
      border-color: var(--color-border-light);
    }
    .view-toggle-btn.active {
      border-color: var(--color-primary-light);
      color: var(--color-text-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CROSSHAIR & MARK INFO
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: bold;
      color: red;
      pointer-events: none;
      user-select: none;
    }
    
    #markInfo {
      position: fixed;
      bottom: var(--spacing-xl);
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: var(--color-text-primary);
      padding: 12px var(--spacing-xl);
      font-size: var(--font-size-md);
      line-height: var(--line-height);
      border-radius: var(--radius-xl);
      z-index: var(--z-debug);
      pointer-events: none;
      min-width: 200px;
      text-align: center;
      display: none;
      box-shadow: var(--shadow-md);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MAP MARKS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .mark {
      position: absolute;
      pointer-events: none;
      z-index: var(--z-marks);
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    .mark-dot {
      width: 24px;
      height: 24px;
      background-image: url("mark/dot.svg");
      filter: invert(87%) sepia(0%) saturate(899%) hue-rotate(202deg) brightness(89%) contrast(91%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }
    .mark-city {
      width: 36px;
      height: 36px;
      background-image: url("mark/city.svg");
      filter: invert(84%) sepia(45%) saturate(1468%) hue-rotate(356deg) brightness(99%) contrast(106%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }
    .mark-dungeon {
      width: 24px;
      height: 24px;
      background-image: url("mark/dungeon.svg");
      filter: invert(12%) sepia(78%) saturate(3968%) hue-rotate(1deg) brightness(84%) contrast(122%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }
    .mark-fight {
      width: 24px;
      height: 24px;
      background-image: url("mark/fight.svg");
      filter: invert(53%) sepia(85%) saturate(4160%) hue-rotate(327deg) brightness(85%) contrast(114%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }
    .mark-treasure {
      width: 24px;
      height: 24px;
      background-image: url("mark/treasure.svg");
      filter: invert(57%) sepia(99%) saturate(1376%) hue-rotate(1deg) brightness(104%) contrast(105%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }
    .mark-landmark {
      width: 24px;
      height: 24px;
      background-image: url("mark/landmark.svg");
      filter: invert(47%) sepia(29%) saturate(2821%) hue-rotate(152deg) brightness(104%) contrast(101%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }
    .mark-enemy {
      width: 36px;
      height: 36px;
      background-image: url("mark/enemy.svg");
      filter: invert(26%) sepia(84%) saturate(5394%) hue-rotate(354deg) brightness(88%) contrast(134%) drop-shadow(0 0 7px rgba(0,0,0,1));
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       EDIT MODE BUTTON
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #editModeBtn {
      position: fixed;
      top: var(--spacing-md);
      left: var(--spacing-md);
      padding: var(--spacing-md) var(--spacing-xl);
      background: var(--color-bg-surface);
      color: var(--color-text-primary);
      border: 2px solid var(--color-primary);
      border-radius: var(--radius-lg);
      font-size: var(--font-size-md);
      cursor: pointer;
      z-index: var(--z-controls);
      transition: all var(--transition-normal);
    }
    #editModeBtn:hover {
      background: var(--color-bg-hover);
      border-color: var(--color-primary-light);
    }
    #editModeBtn.active {
      background: var(--color-primary);
      border-color: var(--color-primary-light);
    }
    
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       AUTO-SAVE TOGGLE
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #autoSaveToggle {
      position: absolute;
      top: var(--spacing-md);
      right: 60px;
      padding: var(--spacing-md);
      background: var(--color-bg-surface);
      color: var(--color-text-primary);
      border: 2px solid var(--color-border);
      border-radius: var(--radius-lg);
      font-size: var(--font-size-md);
      cursor: pointer;
      z-index: var(--z-controls);
      transition: all var(--transition-normal);
      display: none;
    }
    #autoSaveToggle.visible {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #autoSaveToggle.active {
      border-color: var(--color-success);
      background: rgba(76, 175, 80, 0.2);
    }
    #autoSaveToggle.disabled {
      border-color: var(--color-danger);
      background: rgba(244, 67, 54, 0.2);
      cursor: not-allowed;
      opacity: 0.7;
    }
    #autoSaveToggle:hover:not(.disabled) {
      background: var(--color-bg-hover);
    }
    
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       REPORT BUG BUTTON
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #reportBugBtn {
      position: absolute;
      top: var(--spacing-md);
      right: var(--spacing-md);
      padding: var(--spacing-md);
      background: var(--color-bg-surface);
      color: var(--color-text-primary);
      border: 2px solid var(--color-danger);
      border-radius: var(--radius-lg);
      font-size: var(--font-size-md);
      cursor: pointer;
      z-index: var(--z-controls);
      transition: all var(--transition-normal);
      text-decoration: none;
    }
    #reportBugBtn:hover {
      background: var(--color-bg-hover);
      border-color: var(--color-danger-light);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SIDEBAR
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #editSidebar {
      position: fixed;
      left: -380px;
      top: 0;
      width: 380px;
      height: 100%;
      background: var(--color-bg-panel);
      border-right: 2px solid var(--color-border-dark);
      z-index: var(--z-sidebar);
      transition: left var(--transition-normal);
      overflow-y: auto;
      color: var(--color-text-primary);
    }
    #editSidebar.active {
      left: 0;
    }
    
    /* Scrollbar styling*/
    #editSidebar::-webkit-scrollbar {
      width: 8px;
    }
    #editSidebar::-webkit-scrollbar-track {
      background: rgba(40, 40, 40, 0.5);
    }
    #editSidebar::-webkit-scrollbar-thumb {
      background: var(--color-text-disabled);
      border-radius: var(--radius-md);
    }
    #editSidebar::-webkit-scrollbar-thumb:hover {
      background: var(--color-text-muted);
    }
    
    .sidebar-header {
      padding: 54px var(--spacing-xl) var(--spacing-xl) var(--spacing-xl);
      background: var(--color-bg-surface);
      border-bottom: 2px solid #444;
    }
    .sidebar-header h2 {
      margin: 0 0 var(--spacing-lg) 0;
      font-size: var(--font-size-2xl);
      color: var(--color-primary);
    }
    
    .sidebar-content {
      padding: var(--spacing-xl);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MODE TABS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .mode-tabs {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-sm);
      margin-top: var(--spacing-lg);
    }
    .mode-tab {
      padding: var(--spacing-md);
      background: rgba(50, 50, 50, 0.8);
      border: 2px solid var(--color-border);
      border-radius: var(--radius-md);
      cursor: pointer;
      text-align: center;
      font-size: var(--font-size-base);
      transition: all var(--transition-fast);
    }
    .mode-tab:hover {
      background: rgba(60, 60, 60, 0.8);
      border-color: var(--color-border-light);
    }
    .mode-tab.active {
      background: var(--color-primary);
      border-color: var(--color-primary-light);
      color: var(--color-text-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       FORM ELEMENTS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .form-group {
      margin-bottom: var(--spacing-lg);
    }
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-size: var(--font-size-base);
      color: var(--color-text-secondary);
    }
    .form-group label.compact {
      margin-bottom: 3px;
    }
    .form-group label .required {
      color: var(--color-danger-light);
      margin-left: 2px;
    }
    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: var(--spacing-sm) var(--spacing-md);
      background: var(--color-bg-input);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
    }
    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--color-primary);
    }
    .form-group textarea {
      resize: vertical;
      min-height: 60px;
    }
    .form-group input:disabled,
    .form-group textarea:disabled,
    .form-group select:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      background: rgba(30, 30, 30, 0.9);
    }
    
    /* Coordinate input group*/
    .coord-group {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: var(--spacing-sm);
      align-items: end;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUTTONS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .btn {
      padding: var(--spacing-md);
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: var(--font-size-md);
      transition: all var(--transition-fast);
    }
    .btn-primary {
      background: var(--color-primary);
      color: var(--color-text-primary);
    }
    .btn-primary:hover {
      background: var(--color-primary-light);
    }
    .btn-secondary {
      background: #757575;
      color: var(--color-text-primary);
    }
    .btn-secondary:hover {
      background: #9E9E9E;
    }
    .btn-danger {
      background: var(--color-danger);
      color: var(--color-text-primary);
    }
    .btn-danger:hover {
      background: var(--color-danger-light);
    }
    .btn-warning {
      background: var(--color-primary);
      color: var(--color-text-primary);
    }
    .btn-warning:hover {
      background: var(--color-primary-light);
    }
    .btn-edit {
      background: var(--color-secondary);
      margin-right: 5px;
    }
    .btn-edit:hover {
      background: var(--color-secondary-light);
    }
    
    .btn-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-md);
      margin-top: var(--spacing-xl);
    }
    
    .pick-btn {
      height: 32.8px;
      padding: var(--spacing-sm) 12px;
      background: var(--color-secondary);
      border: none;
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      cursor: pointer;
      font-size: 12px;
      white-space: nowrap;
      transition: background var(--transition-fast);
    }
    .pick-btn:hover {
      background: var(--color-secondary-light);
    }
    .pick-btn.active {
      background: var(--color-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       FILE DROP ZONE
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .drop-zone {
      margin-top: var(--spacing-md);
      padding: var(--spacing-xl);
      border: 2px dashed var(--color-border);
      border-radius: var(--radius-md);
      text-align: center;
      background: rgba(40, 40, 40, 0.5);
      cursor: pointer;
      transition: all var(--transition-fast);
    }
    .drop-zone:hover {
      border-color: var(--color-primary);
      background: rgba(255, 152, 0, 0.1);
    }
    .drop-zone-text {
      color: var(--color-text-secondary);
      font-size: 12px;
      margin-bottom: var(--spacing-sm);
    }
    .drop-zone-preview {
      margin-top: var(--spacing-md);
      display: none;
    }
    .drop-zone-preview img {
      max-width: 100%;
      max-height: 150px;
      border-radius: var(--radius-md);
    }
    .drop-zone-info {
      margin-top: 5px;
      font-size: var(--font-size-sm);
      color: var(--color-text-muted);
      word-wrap: break-word;
    }
    
    .hidden-input {
      display: none;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CHECKBOX STYLING
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .checkbox-wrapper {
      margin-bottom: var(--spacing-lg);
    }
    .checkbox-wrapper.compact {
      margin-top: 5px;
      margin-bottom: var(--spacing-md);
    }
    .checkbox-wrapper.hidden {
      display: none;
    }
    .checkbox-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-size: var(--font-size-base);
      color: #ddd;
      padding: var(--spacing-sm);
      user-select: none;
    }
    .checkbox-label:hover .checkbox-text {
      color: var(--color-text-primary);
    }
    .checkbox-label input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin: 0 var(--spacing-md) 0 0;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background: var(--color-bg-input);
      border: 2px solid var(--color-text-disabled);
      border-radius: var(--radius-sm);
      position: relative;
      flex-shrink: 0;
    }
    .checkbox-label input[type="checkbox"]:hover {
      border-color: var(--color-primary);
    }
    .checkbox-label input[type="checkbox"]:checked {
      background: var(--color-primary);
      border-color: var(--color-primary-light);
    }
    .checkbox-label input[type="checkbox"]:checked::after {
      content: 'âœ“';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--color-text-primary);
      font-size: var(--font-size-md);
      font-weight: bold;
    }
    .checkbox-label input[type="checkbox"]:focus {
      outline: none;
      border-color: var(--color-primary);
    }
    .checkbox-text {
      flex: 1;
      line-height: 1.3;
      transition: color var(--transition-fast);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SEARCH & DELETE LIST
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .search-wrapper {
      position: relative;
      margin-bottom: var(--spacing-md);
    }
    .search-wrapper::before {
      content: 'ğŸ”';
      position: absolute;
      left: var(--spacing-md);
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      opacity: 0.6;
    }
    .search-input {
      width: 100%;
      padding: var(--spacing-sm) var(--spacing-md) var(--spacing-sm) 36px;
      background: var(--color-bg-input);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      transition: border-color var(--transition-fast);
    }
    .search-input:focus {
      outline: none;
      border-color: var(--color-primary);
    }
    .search-input::placeholder {
      color: var(--color-text-muted);
    }
    
    .delete-section {
      margin-top: var(--spacing-2xl);
      padding-top: var(--spacing-xl);
      border-top: 2px solid #444;
    }
    .delete-section h4 {
      margin: 0 0 var(--spacing-md) 0;
      font-size: var(--font-size-md);
      color: var(--color-primary);
    }
    
    .delete-list {
      height: 200px;
      overflow-y: auto;
      background: rgba(30, 30, 30, 0.5);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      padding: 5px;
      resize: vertical;
      min-height: 100px;
    }
    .delete-list::-webkit-scrollbar {
      width: 6px;
    }
    .delete-list::-webkit-scrollbar-track {
      background: rgba(40, 40, 40, 0.5);
    }
    .delete-list::-webkit-scrollbar-thumb {
      background: var(--color-text-disabled);
      border-radius: var(--radius-sm);
    }
    
    .delete-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      background: rgba(50, 50, 50, 0.5);
      border-radius: var(--radius-sm);
      margin-bottom: 5px;
      font-size: 12px;
      transition: all var(--transition-fast);
      position: relative;
    }
    .delete-item.draggable {
      cursor: grab;
    }
    .delete-item.draggable:active {
      cursor: grabbing;
    }
    .delete-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    .delete-item.drag-over {
      border-top: 2px solid var(--color-primary);
      margin-top: 2px;
    }
    .delete-item.drag-valid-zone {
      background: rgba(255, 152, 0, 0.15);
      border: 1px solid rgba(255, 152, 0, 0.3);
    }
    .delete-item.drag-invalid-zone {
      opacity: 0.3;
      pointer-events: none;
    }
    .delete-item-drag-handle {
      margin-right: var(--spacing-sm);
      color: var(--color-text-muted);
      cursor: grab;
      user-select: none;
      font-size: var(--font-size-md);
    }
    .delete-item-drag-handle:active {
      cursor: grabbing;
    }
    .delete-item-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-right: var(--spacing-md);
    }
    
    .delete-btn-small {
      padding: var(--spacing-xs) var(--spacing-sm);
      background: var(--color-danger);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--color-text-primary);
      cursor: pointer;
      font-size: var(--font-size-sm);
      transition: background var(--transition-fast);
    }
    .delete-btn-small:hover {
      background: var(--color-danger-light);
    }
    .delete-btn-small.btn-edit {
      background: var(--color-secondary);
      margin-right: 5px;
    }
    .delete-btn-small.btn-edit:hover {
      background: var(--color-secondary-light);
    }
    
    .empty-list {
      padding: var(--spacing-lg);
      text-align: center;
      color: var(--color-border-light);
      font-size: 12px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MODE CONTENT & SECTIONS
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .mode-content {
      display: none;
    }
    .mode-content.active {
      display: block;
    }
    
    .conditional-section {
      display: none;
    }
    .conditional-section.visible {
      display: block;
    }
    
    .info-text {
      padding: var(--spacing-md);
      background: rgba(33, 150, 243, 0.15);
      border-left: 3px solid var(--color-secondary);
      border-radius: var(--radius-md);
      font-size: 12px;
      color: var(--color-text-secondary);
      margin-bottom: var(--spacing-lg);
    }
    
    .data-actions {
      margin-top: var(--spacing-2xl);
      padding-top: var(--spacing-xl);
      border-top: 2px solid #444;
    }
    .data-actions h3 {
      margin: 0 0 var(--spacing-lg) 0;
      font-size: var(--font-size-lg);
      color: var(--color-primary);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       FORM MESSAGES
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .form-message {
      padding: 12px var(--spacing-lg);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-lg);
      font-size: var(--font-size-base);
      display: none;
      animation: slideIn var(--transition-normal);
    }
    .form-message.success {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid var(--color-success);
      color: var(--color-success);
    }
    .form-message.error {
      background: rgba(244, 67, 54, 0.2);
      border: 1px solid var(--color-danger);
      color: var(--color-danger);
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       GALLERY MODAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    .gallery-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--color-bg-overlay);
      z-index: var(--z-modal);
      justify-content: center;
      align-items: center;
    }
    .gallery-modal.active {
      display: flex;
    }
    .gallery-window {
      background: #1a1a1a;
      border: 2px solid var(--color-primary);
      border-radius: var(--radius-xl);
      width: 90%;
      max-width: 900px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shadow-lg);
    }
    .gallery-header {
      padding: var(--spacing-lg) var(--spacing-xl);
      border-bottom: 2px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .gallery-header h3 {
      margin: 0;
      color: var(--color-primary);
      font-size: var(--font-size-xl);
    }
    .gallery-close {
      background: var(--color-danger);
      border: none;
      color: var(--color-text-primary);
      width: 30px;
      height: 30px;
      border-radius: var(--radius-full);
      cursor: pointer;
      font-size: var(--font-size-xl);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background var(--transition-fast);
    }
    .gallery-close:hover {
      background: var(--color-danger-light);
    }
    .gallery-tabs {
      display: flex;
      gap: var(--spacing-md);
      padding: var(--spacing-lg) var(--spacing-xl);
      background: rgba(40, 40, 40, 0.5);
      border-bottom: 1px solid #444;
    }
    .gallery-tabs.hidden {
      display: none;
    }
    .gallery-tab {
      padding: var(--spacing-sm) 16px;
      background: rgba(60, 60, 60, 0.5);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-secondary);
      cursor: pointer;
      font-size: var(--font-size-base);
      transition: all var(--transition-fast);
    }
    .gallery-tab:hover {
      background: rgba(80, 80, 80, 0.7);
      color: var(--color-text-primary);
    }
    .gallery-tab.active {
      background: var(--color-primary);
      border-color: var(--color-primary-light);
      color: var(--color-text-primary);
    }
    .gallery-breadcrumb {
      padding: var(--spacing-md) var(--spacing-xl);
      background: rgba(35, 35, 35, 0.5);
      border-bottom: 1px solid #444;
      color: var(--color-text-secondary);
      font-size: var(--font-size-base);
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .gallery-breadcrumb-item {
      color: var(--color-primary-light);
      cursor: pointer;
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
    }
    .gallery-breadcrumb-item:hover {
      background: rgba(255, 183, 77, 0.2);
      color: var(--color-warning);
    }
    .gallery-breadcrumb-item.drag-over {
      background: rgba(255, 152, 0, 0.4);
      color: var(--color-warning);
      font-weight: bold;
    }
    .gallery-breadcrumb-separator {
      color: var(--color-text-disabled);
      user-select: none;
    }
    .gallery-controls {
      padding: var(--spacing-lg) var(--spacing-xl);
      background: rgba(30, 30, 30, 0.5);
      border-bottom: 1px solid #444;
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
      flex-wrap: wrap;
    }
    .gallery-search {
      flex: 1;
      min-width: 200px;
      padding: var(--spacing-sm) 12px;
      background: var(--color-bg-input);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
    }
    .gallery-search:focus {
      outline: none;
      border-color: var(--color-primary);
    }
    .gallery-sort {
      padding: var(--spacing-sm) 12px;
      background: var(--color-bg-input);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      color: var(--color-text-primary);
      font-size: var(--font-size-base);
      cursor: pointer;
    }
    .gallery-sort:focus {
      outline: none;
      border-color: var(--color-primary);
    }
    .gallery-content {
      padding: var(--spacing-xl);
      overflow-y: auto;
      flex: 1;
      position: relative;
    }
    .gallery-content.drag-over {
      background: rgba(255, 152, 0, 0.1);
      border: 2px dashed var(--color-primary);
    }
    .gallery-content.drag-over::before {
      content: 'ğŸ“¤ Drop files here to upload';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: var(--color-primary);
      pointer-events: none;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.8);
      padding: var(--spacing-xl) 40px;
      border-radius: var(--radius-xl);
    }
    .gallery-content::-webkit-scrollbar {
      width: 8px;
    }
    .gallery-content::-webkit-scrollbar-track {
      background: rgba(40, 40, 40, 0.5);
    }
    .gallery-content::-webkit-scrollbar-thumb {
      background: var(--color-text-disabled);
      border-radius: var(--radius-md);
    }
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: var(--spacing-lg);
    }
    .gallery-item {
      background: rgba(40, 40, 40, 0.8);
      border: 2px solid var(--color-border);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      cursor: pointer;
      transition: all var(--transition-fast);
      position: relative;
    }
    .gallery-item:hover {
      border-color: var(--color-primary);
    }
    .gallery-item-preview {
      width: 100%;
      height: 120px;
      background: #222;
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      margin-bottom: var(--spacing-sm);
    }
    .gallery-item-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    .gallery-item-preview.sound {
      font-size: 48px;
    }
    .gallery-item-preview.folder {
      font-size: 56px;
      background: rgba(70, 70, 70, 0.5);
    }
    .gallery-item.folder-item {
      border-color: var(--color-primary-light);
    }
    .gallery-item.folder-item:hover {
      border-color: var(--color-primary);
    }
    .gallery-item.folder-item.drag-over {
      border-color: var(--color-primary);
      background: rgba(255, 152, 0, 0.2);
      transform: scale(1.05);
    }
    .gallery-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    .gallery-item[draggable="true"] {
      cursor: grab;
    }
    .gallery-item-name {
      font-size: 12px;
      color: var(--color-text-primary);
      margin-bottom: var(--spacing-xs);
      word-wrap: break-word;
      text-align: center;
    }
    .gallery-item-name input {
      width: 100%;
      background: rgba(60, 60, 60, 0.9);
      border: 1px solid var(--color-primary);
      border-radius: var(--radius-sm);
      padding: var(--spacing-xs) 6px;
      color: var(--color-text-primary);
      font-size: 12px;
      text-align: center;
    }
    .gallery-item-info {
      font-size: var(--font-size-xs);
      color: var(--color-text-muted);
      text-align: center;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .gallery-item-refs {
      background: rgba(33, 150, 243, 0.2);
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      color: var(--color-secondary);
    }
    .gallery-item-refs.zero {
      background: rgba(76, 175, 80, 0.2);
      color: var(--color-success);
    }
    .gallery-item-update {
      position: absolute;
      top: var(--spacing-sm);
      left: var(--spacing-sm);
      width: 24px;
      height: 24px;
      background: var(--color-secondary);
      border: 2px solid var(--color-text-primary);
      border-radius: var(--radius-full);
      color: var(--color-text-primary);
      font-size: 16px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-fast);
      z-index: 1;
    }
    .gallery-item-update:hover {
      background: var(--color-secondary-light);
    }
    .gallery-item-delete {
      position: absolute;
      top: var(--spacing-sm);
      right: var(--spacing-sm);
      width: 24px;
      height: 24px;
      background: var(--color-danger);
      border: 2px solid var(--color-text-primary);
      border-radius: var(--radius-full);
      color: var(--color-text-primary);
      font-size: var(--font-size-md);
      font-weight: bold;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-fast);
      z-index: 1;
    }
    .gallery-item-delete:hover {
      background: var(--color-danger-light);
    }
    .gallery-item-delete.can-delete {
      display: flex;
    }
    .gallery-empty {
      text-align: center;
      padding: 40px;
      color: var(--color-border-light);
      font-size: var(--font-size-md);
    }
    .gallery-btn {
      background: rgba(255, 152, 0, 0.2);
      border: 1px solid var(--color-primary);
      color: var(--color-primary);
      padding: var(--spacing-sm) 16px;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: var(--font-size-base);
      transition: all var(--transition-fast);
      white-space: nowrap;
      width: 100%;
      margin-top: var(--spacing-md);
    }
    .gallery-btn:hover {
      background: rgba(255, 152, 0, 0.3);
      border-color: var(--color-primary-light);
    }
    .gallery-btn.compact {
      margin-top: 0;
      width: auto;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LOADING SCREEN
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•*/
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--color-bg-dark);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: var(--z-modal);
      transition: opacity var(--transition-normal);
    }
    #loadingScreen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid var(--color-primary);
      border-radius: var(--radius-full);
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading-text {
      color: var(--color-text-primary);
      font-size: var(--font-size-xl);
      margin-top: var(--spacing-xl);
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingScreen">
    <div class="spinner"></div>
    <div class="loading-text">Loading map data...</div>
  </div>
  
  <button id="editModeBtn">Edit Mode</button>
  
  <div id="editSidebar">
    <button id="autoSaveToggle" title="Auto-save changes">
      <span>ğŸ’¾</span>
      <span>Auto</span>
    </button>
    <a id="reportBugBtn" href="mailto:ime.bugreport@gmail.com?subject=BUG%20-%20Title" target="_blank">ğŸª²</a>

    <div class="sidebar-header">
      <div class="mode-tabs">
        <div class="mode-tab" data-mode="image">ğŸ–¼ï¸ Image</div>
        <div class="mode-tab" data-mode="mark">ğŸ“ Mark</div>
        <div class="mode-tab" data-mode="sound">ğŸ”Š Sound</div>
        <div class="mode-tab" data-mode="gallery">ğŸ—‚ï¸ Gallery</div>
      </div>
    </div>
    
    <div class="sidebar-content">
      <!-- Drag Mode -->
      <div class="mode-content active" id="dragMode">
        <div class="info-text">
          Select a a mode to start editing the map.
        </div>
      </div>

      <!-- Image Mode -->
      <div class="mode-content" id="imageMode">
        <div class="info-text">
          Add or edit image nodes. Mark fields with * are mandatory.
        </div>
        
        <div class="form-group">
          <label>Name (optional)</label>
          <input type="text" id="img_name" placeholder="e.g., Monzun City, Main Castle...">
        </div>
        
        <div class="form-group">
          <label>URL<span class="required">*</span></label>
          <input type="text" id="img_url" placeholder="img/example.png or upload below">
          <div class="drop-zone" id="img_drop_zone">
            <div class="drop-zone-text">ğŸ“ Drag & Drop image here or click to browse</div>
            <input type="file" id="img_file_input" accept="image/*" class="hidden-input">
            <div id="img_preview" class="drop-zone-preview">
              <img id="img_preview_img">
              <div id="img_file_info" class="drop-zone-info"></div>
            </div>
          </div>
          <button class="gallery-btn" onclick="openGallery('image', false)">ğŸ–¼ï¸ Open Gallery</button>
        </div>
        
        <div class="form-group">
          <label>Position <span class="required">*</span></label>
          <div class="coord-group">
            <div>
              <label class="compact">X</label>
              <input type="number" id="img_x" step="0.1" placeholder="0">
            </div>
            <div>
              <label class="compact">Y</label>
              <input type="number" id="img_y" step="0.1" placeholder="0">
            </div>
            <button class="pick-btn" id="img_pick">Pick</button>
          </div>
        </div>
        
        <div class="form-group">
          <label>Appear Scale <span class="required">*</span></label>
          <input type="number" id="img_appearScale" step="0.1" placeholder="0" value="0">
        </div>
        
        <div class="form-group">
          <label>Size <span class="required">*</span></label>
          <input type="number" id="img_size" step="0.001" placeholder="1" value="1">
        </div>
        
        <div class="form-group">
          <label>Parent (optional)</label>
          <select id="img_parent">
            <option value="">None (Root Level)</option>
          </select>
        </div>
        
        <div class="checkbox-wrapper hidden" id="img_update_children_wrapper">
          <label class="checkbox-label">
            <input type="checkbox" id="img_update_children" checked>
            <span class="checkbox-text">Update children when modifying position/size</span>
          </label>
        </div>
        
        <div class="form-message" id="img_message"></div>
        
        <div class="btn-group">
          <button class="btn btn-primary" id="img_add">Add Image</button>
          <button class="btn btn-secondary" id="img_clear">Clear</button>
        </div>
        
        <div class="delete-section">
          <h4>ğŸ› ï¸ Manage Images</h4>
          <div class="search-wrapper">
            <input type="text" id="img_search" class="search-input" placeholder="Search images...">
          </div>
          <div class="checkbox-wrapper compact">
            <label class="checkbox-label">
              <input type="checkbox" id="img_show_children">
              <span class="checkbox-text">Show children in search</span>
            </label>
          </div>
          <div class="delete-list" id="img_delete_list">
            <div class="empty-list">No images to delete</div>
          </div>
        </div>
      </div>
      
      <!-- Mark Mode -->
      <div class="mode-content" id="markMode">
        <div class="info-text">
          Add or edit marks. Mark fields with * are mandatory.
        </div>
        
        <div class="form-group">
          <label>Mark Type</label>
          <select id="mark_type">
            <option value="node">Node Mark (attached to image)</option>
            <option value="general">General Mark (always visible)</option>
          </select>
        </div>
        
        <div id="mark_node_section">
          <div class="form-group">
            <label>Select Node <span class="required">*</span></label>
            <select id="mark_node">
              <option value="">Choose a node...</option>
            </select>
          </div>
        </div>
        
        <div id="mark_general_section" class="conditional-section">
          <div class="form-group">
            <label>Position <span class="required">*</span></label>
            <div class="coord-group">
              <div>
                <label class="compact">X</label>
                <input type="number" id="mark_x" step="0.1" placeholder="0">
              </div>
              <div>
                <label class="compact">Y</label>
                <input type="number" id="mark_y" step="0.1" placeholder="0">
              </div>
              <button class="pick-btn" id="mark_pick">Pick</button>
            </div>
          </div>
          
          <div class="form-group">
            <label>Mark Name <span class="required">*</span></label>
            <input type="text" id="mark_name" placeholder="e.g., Piazza, Dungeon Dark Vision...">
          </div>
          
          <div class="form-group">
            <label>Parent (optional)</label>
            <select id="mark_parent">
              <option value="">None (Always visible)</option>
            </select>
          </div>
        </div>
        
        <div class="form-group">
          <label>Mark Style</label>
          <select id="mark_markType">
            <option value="">Dot (default)</option>
            <option value="city">City</option>
            <option value="dungeon">Dungeon</option>
            <option value="fight">Fight/Monster</option>
            <option value="treasure">Treasure</option>
            <option value="landmark">Landmark</option>
            <option value="enemy">Enemy/Boss</option>
          </select>
        </div>
        
        <div class="form-group">
          <label>Mark Description</label>
          <textarea id="mark_description" placeholder="Description of the location..."></textarea>
        </div>
        
        <div class="form-message" id="mark_message"></div>
        
        <div class="btn-group">
          <button class="btn btn-primary" id="mark_add">Add Mark</button>
          <button class="btn btn-secondary" id="mark_clear">Clear</button>
        </div>
        
        <div class="delete-section">
          <h4>ğŸ› ï¸ Manage Marks</h4>
          <div class="search-wrapper">
            <input type="text" id="mark_search" class="search-input" placeholder="Search marks...">
          </div>
          <div class="delete-list" id="mark_delete_list">
            <div class="empty-list">No marks to delete</div>
          </div>
        </div>
      </div>
      
      <!-- Sound Mode -->
      <div class="mode-content" id="soundMode">
        <div class="info-text">
          Add or edit sound zones. Mark fields with * are mandatory.
        </div>
        
        <div class="form-group">
          <label>Name (optional)</label>
          <input type="text" id="sound_name" placeholder="e.g., Forest Ambience, Town Music...">
        </div>
        
        <div class="form-group">
          <label>Sound URL <span class="required">*</span></label>
          <input type="text" id="sound_url" placeholder="sound/example.mp3 or upload below">
          <div class="drop-zone" id="sound_drop_zone">
            <div class="drop-zone-text">ğŸµ Drag & Drop audio here or click to browse</div>
            <input type="file" id="sound_file_input" accept="audio/*" class="hidden-input">
            <div id="sound_preview" class="drop-zone-preview">
              <div id="sound_file_info" class="drop-zone-info"></div>
            </div>
          </div>
          <button class="gallery-btn" onclick="openGallery('sound', false)">ğŸµ Open Gallery</button>
        </div>
        
        <div class="form-group">
          <label>Zone Corner 1 <span class="required">*</span></label>
          <div class="coord-group">
            <div>
              <label class="compact">X1</label>
              <input type="number" id="sound_x1" step="0.1" placeholder="0">
            </div>
            <div>
              <label class="compact">Y1</label>
              <input type="number" id="sound_y1" step="0.1" placeholder="0">
            </div>
            <button class="pick-btn" id="sound_pick1">Pick</button>
          </div>
        </div>
        
        <div class="form-group">
          <label>Zone Corner 2 <span class="required">*</span></label>
          <div class="coord-group">
            <div>
              <label class="compact">X2</label>
              <input type="number" id="sound_x2" step="0.1" placeholder="0">
            </div>
            <div>
              <label class="compact">Y2</label>
              <input type="number" id="sound_y2" step="0.1" placeholder="0">
            </div>
            <button class="pick-btn" id="sound_pick2">Pick</button>
          </div>
        </div>
        
        <div class="form-group">
          <label>Min Scale <span class="required">*</span></label>
          <input type="number" id="sound_minScale" step="0.1" placeholder="0" value="0">
        </div>
        
        <div class="form-group">
          <label>Max Scale (optional)</label>
          <input type="number" id="sound_maxScale" step="0.1" placeholder="Leave empty for no max">
        </div>
        
        <div class="form-message" id="sound_message"></div>
        
        <div class="btn-group">
          <button class="btn btn-primary" id="sound_add">Add Sound</button>
          <button class="btn btn-secondary" id="sound_clear">Clear</button>
        </div>
        
        <div class="delete-section">
          <h4>ğŸ› ï¸ Manage Sounds</h4>
          <div class="search-wrapper">
            <input type="text" id="sound_search" class="search-input" placeholder="Search sounds...">
          </div>
          <div class="checkbox-wrapper compact">
            <label class="checkbox-label">
              <input type="checkbox" id="sound_show_children">
              <span class="checkbox-text">Show children in search</span>
            </label>
          </div>
          <div class="delete-list" id="sound_delete_list">
            <div class="empty-list">No sounds to delete</div>
          </div>
        </div>
      </div>
      
      <!-- Data Management -->
      <div class="data-actions">
        <h3>Data Management</h3>
        <div class="btn-group">
          <button class="btn btn-primary" id="data_download">ğŸ’¾ Download</button>
          <button class="btn btn-secondary" id="data_upload">ğŸ“ Upload</button>
        </div>
        <input type="file" id="data_file" accept=".json" class="hidden-input">
      </div>
      
      <!-- Gallery Mode -->
      <div class="mode-content" id="galleryMode">
        <div class="info-text">
          Gallery management mode. Click the button below to open the gallery.
        </div>
        <button class="gallery-btn" onclick="openGallery('image', true)">ğŸ—‚ï¸ Open Gallery</button>
      </div>
    </div>
  </div>
  
  <canvas id="canvas"></canvas>
  <div class="view-toggles">
    <button class="view-toggle-btn active" id="toggleMarks">ğŸ“</button>
    <button class="view-toggle-btn active" id="toggleSounds">ğŸ”Š</button>
  </div>
  <div id="debug">x: â€” , y: â€” , zoom: â€”</div>
  <div id="crosshair">+</div>
  <div id="markInfo"></div>
  
  <!-- Gallery Modal -->
  <div class="gallery-modal" id="galleryModal">
    <div class="gallery-window">
      <div class="gallery-header">
        <h3>ğŸ–¼ï¸ Gallery</h3>
        <button class="gallery-close" onclick="closeGallery()">Ã—</button>
      </div>
      <div class="gallery-tabs hidden">
        <div class="gallery-tab active" data-type="image" onclick="switchGalleryTab('image')">ğŸ–¼ï¸ Images</div>
        <div class="gallery-tab" data-type="sound" onclick="switchGalleryTab('sound')">ğŸµ Sounds</div>
      </div>
      <div class="gallery-breadcrumb" id="galleryBreadcrumb"></div>
      <div class="gallery-controls">
        <input type="text" class="gallery-search" id="gallerySearch" placeholder="ğŸ” Search gallery..." oninput="renderGallery()">
        <select class="gallery-sort" id="gallerySort" onchange="renderGallery()">
          <option value="name-asc">Name (A-Z)</option>
          <option value="name-desc">Name (Z-A)</option>
          <option value="date-desc">Newest First</option>
          <option value="date-asc">Oldest First</option>
        </select>
        <button class="gallery-btn compact" onclick="createFolder()">ğŸ“ New Folder</button>
        <button class="gallery-btn compact" onclick="uploadToGallery()">ğŸ“¤ Upload</button>
        <input type="file" id="gallery_file_input" accept="image/*,audio/*" multiple class="hidden-input">
      </div>
      <div class="gallery-content" id="galleryContent">
        <div class="gallery-empty">No items in gallery</div>
      </div>
    </div>
  </div>

  <script>
    /*
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * INTERACTIVE MAP EDITOR - v2.0 (Refactored)
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * 
     * A Canvas-based interactive map editor with hierarchical layers, markers, and audio.
     * 
     * Architecture:
     * - AppState: Global application state management
     * - Utils: Helper functions and utilities
     * - CanvasManager: Canvas rendering and drawing
     * - NavigationController: Mouse/touchpad/touchscreen navigation
     * - ImageSystem: Hierarchical image layers
     * - MarkSystem: Interactive markers
     * - SoundSystem: Spatial audio zones
     * - GalleryManager: Asset library management
     * - EditModeController: Edit mode UI and form handling
     * - DataManager: Save/load/export functionality
     * - DragDropController: List reordering
    */

    'use strict';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // APPLICATION STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /*
     * Centralized application state
    */
    const AppState = {
      // Canvas & View
      canvas: null,
      ctx: null,
      scale: 1,
      originX: 0,
      originY: 0,
      
      // Interaction state
      isDragging: false,
      hasDragged: false,
      dragStartX: 0,
      dragStartY: 0,
      userInteracted: false,
      mouseX: 0,
      mouseY: 0,
      hoveredMark: null,
      
      // Data arrays
      config: [],
      generalMarks: [],
      sounds: [],
      gallery: [],
      marks: [],
      
      // Gallery navigation
      currentGalleryFolder: { image: 'image', sound: 'sound' },
      
      // Edit mode state
      editMode: false,
      currentMode: 'drag',
      pickingCoord: null,
      editingNodePath: null,
      editingMarkData: null,
      editingSoundIndex: null,
      
      // View toggles
      markMode: 0, // 0=land only, 1=enemy only, 2=all, 3=none
      showSounds: true,
      
      // Auto-save
      fileHandle: null,
      autoSave: false,
      hasUnsavedChanges: false,
      
      // Backup data for reset
      backupImageData: null,
      backupMarkData: null,
      backupSoundData: null,
      
      // Message timeouts
      messageTimeouts: {},
      
      // Touch state
      touches: {},
      initialDistance: 0,
      initialScale: 1,
      touchStartOriginX: 0,
      touchStartOriginY: 0,
      
      // Drag and drop state
      draggedElement: null,
      draggedIndex: null,
      draggedData: null,
      autoScrollInterval: null,
      
      // Gallery selection
      currentGalleryType: 'image',
      gallerySelectMode: false,
      gallerySelectCallback: null,
      
      // Auto-save timeout
      autoSaveTimeout: null
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITY FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const Utils = {
      /*
       * Get DOM element by ID
      */
      $(id) {
        return document.getElementById(id);
      },

      /*
       * Query selector shorthand
      */
      $$(selector) {
        return document.querySelectorAll(selector);
      },

      /*
       * Generate unique gallery ID
      */
      generateGalleryId() {
        let id;
        do {
          id = `gal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        } while (AppState.gallery.some(item => item.id === id));
        return id;
      },

      /*
       * Get gallery item name from ID (returns original if not a gallery ID)
      */
      getGalleryItemName(nameOrId) {
        if (!nameOrId || !nameOrId.startsWith('gal_')) return nameOrId;
        const item = AppState.gallery.find(i => i.id === nameOrId);
        return item ? item.name : nameOrId;
      },

      /*
       * Resolve gallery reference to actual content URL
      */
      resolveGalleryUrl(url) {
        if (!url || !url.startsWith('gallery:')) return url;
        const galleryId = url.substring(8);
        const galleryItem = AppState.gallery.find(item => item.id === galleryId);
        return galleryItem ? galleryItem.content : url;
      },

      /*
       * Convert screen coordinates to world coordinates
      */
      screenToWorld(screenX, screenY) {
        const { canvas, scale, originX, originY } = AppState;
        return {
          x: (screenX - canvas.width / 2) / scale + originX,
          y: (screenY - canvas.height / 2) / scale + originY
        };
      },

      /*
       * Convert world coordinates to screen coordinates
      */
      worldToScreen(worldX, worldY) {
        const { canvas, scale, originX, originY } = AppState;
        return {
          x: canvas.width / 2 + (worldX - originX) * scale,
          y: canvas.height / 2 + (worldY - originY) * scale
        };
      },

      /*
       * Get node by path string (e.g., "0,1,2")
      */
      getNodeByPath(path) {
        if (!path) return null;
        const indices = path.split(',').map(Number);
        let node = AppState.config;
        for (let i = 0; i < indices.length; i++) {
          node = node[indices[i]];
          if (i < indices.length - 1 && node) {
            node = node.children;
          }
        }
        return node;
      },

      /*
       * Find path to a specific node in the config tree
      */
      findNodePath(nodes, targetNode, parentPath = []) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          const path = [...parentPath, i];
          
          if (node === targetNode) {
            return path.join(',');
          }
          
          if (node.children && node.children.length > 0) {
            const childPath = this.findNodePath(node.children, targetNode, path);
            if (childPath) return childPath;
          }
        }
        return null;
      },

      /*
       * Delete node by path string
      */
      deleteNodeByPath(path) {
        const indices = path.split(',').map(Number);
        
        if (indices.length === 1) {
          AppState.config.splice(indices[0], 1);
        } else {
          let parent = AppState.config[indices[0]];
          for (let i = 1; i < indices.length - 1; i++) {
            parent = parent.children[indices[i]];
          }
          parent.children.splice(indices[indices.length - 1], 1);
        }
        
        MarkSystem.rebuildMarks();
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IMAGE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const ImageSystem = {
      /*
       * Load images for a node and its children
      */
      loadImages(node) {
        node.img = new Image();
        node.imgLoadFailed = false;
        
        node.img.onerror = () => {
          node.imgLoadFailed = true;
          console.warn(`Failed to load image: ${node.src}`);
        };
        
        node.img.onload = () => {
          node.imgLoadFailed = false;
        };
        
        const imageSrc = Utils.resolveGalleryUrl(node.src);
        node.img.src = imageSrc;
        
        if (node.children) {
          node.children.forEach(child => this.loadImages(child));
        }
      },

      /*
       * Draw a node and its children on the canvas
      */
      drawNode(node) {
        const { scale, canvas, originX, originY, ctx } = AppState;
        
        // Check if parent is visible (scale >= appearScale)
        const isVisible = scale >= node.appearScale;
        
        if (isVisible && node.img?.complete && !node.imgLoadFailed && node.img.naturalWidth > 0) {
          const w = node.img.width * node.size * scale;
          const h = node.img.height * node.size * scale;
          const x = canvas.width / 2 + (node.x - originX) * scale - w / 2;
          const y = canvas.height / 2 + (node.y - originY) * scale - h / 2;
          ctx.drawImage(node.img, x, y, w, h);
        }
        
        // Only draw children if parent is visible
        if (isVisible && node.children) {
          node.children.forEach(child => this.drawNode(child));
        }
      },

      /*
       * Find node at position (for click detection)
      */
      findNodeAtPosition(nodes, x, y, parentPath = []) {
        for (let i = nodes.length - 1; i >= 0; i--) {
          const node = nodes[i];
          const path = [...parentPath, i];
          
          // Check children first (they're on top)
          if (node.children?.length && AppState.scale >= node.appearScale) {
            const childResult = this.findNodeAtPosition(node.children, x, y, path);
            if (childResult) return childResult;
          }
          
          // Check if this node is visible and contains the click
          if (AppState.scale >= node.appearScale && node.img?.complete) {
            const w = node.img.width * node.size;
            const h = node.img.height * node.size;
            
            if (x >= node.x - w/2 && x <= node.x + w/2 &&
                y >= node.y - h/2 && y <= node.y + h/2) {
              return { node, path: path.join(',') };
            }
          }
        }
        return null;
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MARK SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const MarkSystem = {
      /*
       * Mark type to CSS class mapping
      */
      markTypeClasses: {
        city: 'mark mark-city',
        dungeon: 'mark mark-dungeon',
        fight: 'mark mark-fight',
        treasure: 'mark mark-treasure',
        landmark: 'mark mark-landmark',
        enemy: 'mark mark-enemy',
        default: 'mark mark-dot'
      },

      /*
       * Initialize marks from config and generalMarks
      */
      initialize() {
        AppState.marks.length = 0;
        AppState.config.forEach(node => this.collectMarks(node));
        
        AppState.generalMarks.forEach(gm => {
          const parentNode = gm.parentPath ? Utils.getNodeByPath(gm.parentPath) : null;
          AppState.marks.push({
            node: gm,
            element: null,
            isGeneral: true,
            parentNode
          });
        });
      },

      /*
       * Collect marks from a node tree
      */
      collectMarks(node, parent = null) {
        if (node.mark !== undefined) {
          AppState.marks.push({
            node,
            parent,
            element: null,
            isGeneral: false
          });
        }
        if (node.children) {
          node.children.forEach(child => this.collectMarks(child, node));
        }
      },

      /*
       * Create a mark DOM element
      */
      createMarkElement(markType) {
        const div = document.createElement('div');
        div.className = this.markTypeClasses[markType] || this.markTypeClasses.default;
        return div;
      },

      /*
       * Check if mouse is hovering over a mark
      */
      checkHover() {
        const { mouseX, mouseY, marks } = AppState;
        const hoverRadius = 20;
        let newHoveredMark = null;
        
        for (const m of marks) {
          if (m.element && m.screenX && m.screenY) {
            const dx = mouseX - m.screenX;
            const dy = mouseY - m.screenY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist <= hoverRadius) {
              newHoveredMark = m;
              break;
            }
          }
        }
        
        if (newHoveredMark !== AppState.hoveredMark) {
          const markInfoDiv = Utils.$('markInfo');
          if (newHoveredMark) {
            const displayName = Utils.getGalleryItemName(newHoveredMark.node.name) || 'Mark';
            const displayMark = newHoveredMark.node.mark || '';
            markInfoDiv.innerHTML = `<strong>${displayName}</strong><br>${displayMark}`;
            markInfoDiv.style.display = 'block';
          } else {
            markInfoDiv.style.display = 'none';
          }
          AppState.hoveredMark = newHoveredMark;
        }
      },

      /*
       * Update marks display based on current view
      */
      update() {
        const { marks, markMode, scale, canvas, originX, originY } = AppState;
        
        // Remove all existing mark elements
        marks.forEach(m => {
          if (m.element?.parentNode) {
            m.element.parentNode.removeChild(m.element);
          }
          m.element = null;
        });
        
        // Don't show marks if mode is 'none'
        if (markMode === 3) return;

        marks.forEach(m => {
          const node = m.node;
          const isEnemy = node.markType === 'enemy';
          
          // Filter based on mark mode
          if (markMode === 0 && isEnemy) return; // Land only - skip enemy
          if (markMode === 1 && !isEnemy) return; // Enemy only - skip non-enemy
          
          let shouldShow = false;
          
          if (m.isGeneral) {
            // General marks: if they have a parent, only show when parent is visible
            shouldShow = m.parentNode ? (scale >= m.parentNode.appearScale) : true;
          } else if (m.parent) {
            // Child mark: show only if parent is visible AND child image is not yet visible
            shouldShow = (scale >= m.parent.appearScale) && (scale < node.appearScale);
          } else {
            // Top-level mark: show only if image is not yet visible
            shouldShow = (scale < node.appearScale);
          }
          
          if (shouldShow) {
            const screenX = canvas.width / 2 + (node.x - originX) * scale;
            const screenY = canvas.height / 2 + (node.y - originY) * scale;
            
            // Check if mark is on screen (with margin)
            if (screenX >= -50 && screenX <= canvas.width + 50 && 
                screenY >= -50 && screenY <= canvas.height + 50) {
              
              const markEl = this.createMarkElement(node.markType);
              markEl.style.left = `${screenX}px`;
              markEl.style.top = `${screenY}px`;
              markEl.style.transform = 'translate(-50%, -50%)';
              
              document.body.appendChild(markEl);
              m.element = markEl;
              m.screenX = screenX;
              m.screenY = screenY;
            }
          }
        });
      },

      /*
       * Rebuild marks array from config and generalMarks
      */
      rebuildMarks() {
        const { marks } = AppState;
        
        // Remove existing mark elements
        marks.forEach(m => {
          if (m.element?.parentNode) {
            m.element.parentNode.removeChild(m.element);
          }
        });
        
        marks.length = 0;
        AppState.config.forEach(node => this.collectMarks(node));
        
        AppState.generalMarks.forEach(gm => {
          const parentNode = gm.parentPath ? Utils.getNodeByPath(gm.parentPath) : null;
          marks.push({
            node: gm,
            element: null,
            isGeneral: true,
            parentNode
          });
        });
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SOUND SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const SoundSystem = {
      /*
       * Color palette for sound zone visualization
      */
      zoneColors: [
        'rgba(33, 150, 243, 0.25)',   // Blue
        'rgba(76, 175, 80, 0.25)',    // Green
        'rgba(255, 152, 0, 0.25)',    // Orange
        'rgba(156, 39, 176, 0.25)',   // Purple
        'rgba(244, 67, 54, 0.25)',    // Red
        'rgba(0, 188, 212, 0.25)',    // Cyan
        'rgba(255, 235, 59, 0.25)',   // Yellow
        'rgba(233, 30, 99, 0.25)',    // Pink
        'rgba(121, 85, 72, 0.25)',    // Brown
        'rgba(96, 125, 139, 0.25)'    // Blue Grey
      ],

      /*
       * Initialize sounds with Audio elements
      */
      initialize() {
        AppState.sounds.forEach(s => {
          const audioSrc = Utils.resolveGalleryUrl(s.src);
          s.audio = new Audio(audioSrc);
          s.audio.loop = true;
          s.audio.volume = 1;
        });
      },

      /*
       * Check if a point is inside a sound zone at current scale
      */
      isInZone(cx, cy, s) {
        const minX = Math.min(s.x1, s.x2);
        const maxX = Math.max(s.x1, s.x2);
        const minY = Math.min(s.y1, s.y2);
        const maxY = Math.max(s.y1, s.y2);
        const okPos = cx >= minX && cx <= maxX && cy >= minY && cy <= maxY;
        const okScale = AppState.scale >= (s.minScale ?? 0) && (s.maxScale ? AppState.scale <= s.maxScale : true);
        return okPos && okScale;
      },

      /*
       * Update sound playback based on current view position
      */
      update() {
        const { userInteracted, showSounds, sounds, originX, originY } = AppState;
        
        if (!userInteracted || !showSounds) return;
        
        const validSounds = sounds.filter(s => this.isInZone(originX, originY, s));
        validSounds.sort((a, b) => (b.minScale ?? 0) - (a.minScale ?? 0));
        const topSound = validSounds[0] || null;
        
        sounds.forEach(s => {
          if (s === topSound) {
            if (!s.playing) {
              s.audio.currentTime = 0;
              s.audio.play().catch(() => {});
              s.playing = true;
            }
          } else if (s.playing) {
            s.audio.pause();
            s.playing = false;
          }
        });
      },

      /*
       * Stop all sounds
      */
      stopAll() {
        AppState.sounds.forEach(s => {
          if (s.playing) {
            s.audio.pause();
            s.playing = false;
          }
        });
      },

      /*
       * Draw sound zones on canvas (for edit mode)
      */
      drawZones() {
        const { showSounds, sounds, canvas, originX, originY, scale, ctx } = AppState;
        
        if (!showSounds) return;
        
        // Sort sounds by minScale (lower first, so higher are drawn on top)
        const sortedSounds = [...sounds].sort((a, b) => (a.minScale || 0) - (b.minScale || 0));
        
        sortedSounds.forEach((sound, index) => {
          const minX = Math.min(sound.x1, sound.x2);
          const maxX = Math.max(sound.x1, sound.x2);
          const minY = Math.min(sound.y1, sound.y2);
          const maxY = Math.max(sound.y1, sound.y2);
          
          // Convert to screen coordinates
          const screenX1 = canvas.width / 2 + (minX - originX) * scale;
          const screenY1 = canvas.height / 2 + (minY - originY) * scale;
          const screenX2 = canvas.width / 2 + (maxX - originX) * scale;
          const screenY2 = canvas.height / 2 + (maxY - originY) * scale;
          
          const width = screenX2 - screenX1;
          const height = screenY2 - screenY1;
          
          // Only draw if zone is at least partially visible
          if (screenX2 >= 0 && screenX1 <= canvas.width && 
              screenY2 >= 0 && screenY1 <= canvas.height) {
            
            const color = this.zoneColors[index % this.zoneColors.length];
            const borderColor = color.replace('0.25', '0.6');
            
            // Draw filled rectangle
            ctx.fillStyle = color;
            ctx.fillRect(screenX1, screenY1, width, height);
            
            // Draw border
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX1, screenY1, width, height);
            
            // Draw label
            const soundName = sound.name || `Sound ${sounds.indexOf(sound) + 1}`;
            const label = Utils.getGalleryItemName(soundName);
            const scaleInfo = `(${sound.minScale}${sound.maxScale ? `-${sound.maxScale}` : '+'})`;
            
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = screenX1 + width / 2;
            const centerY = screenY1 + height / 2;
            
            // Draw text background
            const textMetrics = ctx.measureText(label);
            const textWidth = Math.max(textMetrics.width, ctx.measureText(scaleInfo).width);
            const padding = 6;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(centerX - textWidth/2 - padding, centerY - 15, textWidth + padding * 2, 30);
            
            // Draw text
            ctx.fillStyle = '#ffffff';
            ctx.fillText(label, centerX, centerY - 6);
            ctx.font = '10px Arial';
            ctx.fillText(scaleInfo, centerX, centerY + 8);
          }
        });
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CANVAS MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const CanvasManager = {
      /*
       * Initialize canvas
      */
      init() {
        AppState.canvas = Utils.$('canvas');
        AppState.ctx = AppState.canvas.getContext('2d');
        this.resize();
      },

      /*
       * Resize canvas to window dimensions
      */
      resize() {
        AppState.canvas.width = window.innerWidth;
        AppState.canvas.height = window.innerHeight;
      },

      /*
       * Update debug display
      */
      updateDebug() {
        const { originX, originY, scale } = AppState;
        const dbg = Utils.$('debug');
        dbg.textContent = `x: ${originX.toFixed(1)}, y: ${originY.toFixed(1)}, zoom: ${scale.toFixed(2)}`;
      },

      /*
       * Main render function
      */
      render() {
        const { ctx, canvas, config, editMode, currentMode } = AppState;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw all image nodes
        config.forEach(node => ImageSystem.drawNode(node));
        
        // Draw sound zones if in sound mode and edit mode
        if (editMode && currentMode === 'sound') {
          SoundSystem.drawZones();
        }
        
        // Update marks and sounds
        MarkSystem.update();
        SoundSystem.update();
        this.updateDebug();
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NAVIGATION CONTROLLER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const NavigationController = {
      /*
       * Initialize all navigation event listeners
      */
      init() {
        const { canvas } = AppState;
        
        // Mouse events
        canvas.addEventListener('mousedown', e => this.handleMouseDown(e));
        canvas.addEventListener('mousemove', e => this.handleMouseMove(e));
        canvas.addEventListener('mouseup', () => this.handleMouseUp());
        canvas.addEventListener('mouseleave', () => this.handleMouseUp());
        
        // Wheel event (mouse and touchpad)
        canvas.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
        
        // Touch events
        canvas.addEventListener('touchstart', e => this.handleTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', e => this.handleTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', e => this.handleTouchEnd(e), { passive: false });
        canvas.addEventListener('touchcancel', e => this.handleTouchCancel(e), { passive: false });
        
        // Window resize
        window.addEventListener('resize', () => {
          CanvasManager.resize();
          CanvasManager.render();
        });
      },

      /*
       * Handle mouse down event
      */
      handleMouseDown(e) {
        AppState.userInteracted = true;
        AppState.isDragging = true;
        AppState.hasDragged = false;
        AppState.dragStartX = e.clientX;
        AppState.dragStartY = e.clientY;
      },

      /*
       * Handle mouse move event
      */
      handleMouseMove(e) {
        AppState.mouseX = e.clientX;
        AppState.mouseY = e.clientY;
        MarkSystem.checkHover();
        
        if (!AppState.isDragging) return;
        
        const dx = (e.clientX - AppState.dragStartX) / AppState.scale;
        const dy = (e.clientY - AppState.dragStartY) / AppState.scale;
        
        // Mark as dragged if mouse moved more than a small threshold
        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
          AppState.hasDragged = true;
        }
        
        AppState.originX -= dx;
        AppState.originY -= dy;
        AppState.dragStartX = e.clientX;
        AppState.dragStartY = e.clientY;
        CanvasManager.render();
      },

      /*
       * Handle mouse up event
      */
      handleMouseUp() {
        AppState.isDragging = false;
      },

      /*
       * Handle wheel event (mouse and touchpad)
      */
      handleWheel(e) {
        e.preventDefault();
        AppState.userInteracted = true;
        
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        
        // Detect touchpad vs mouse wheel (touchpad typically has smaller deltaY values)
        const isTouchpad = Math.abs(e.deltaY) < 50 || e.deltaX !== 0;
        
        if (isTouchpad) {
          if (!e.ctrlKey) {
            // Regular scroll - pan the map
            const scrollSpeed = 1.25 / AppState.scale;
            AppState.originX += e.deltaX * scrollSpeed;
            AppState.originY += e.deltaY * scrollSpeed;
          } else {
            // Ctrl + scroll or pinch - zoom (slower than mouse)
            this.zoomAt(mouseX, mouseY, e.deltaY < 0 ? 1.075 : 0.925);
          }
        } else {
          // Mouse wheel - standard zoom
          this.zoomAt(mouseX, mouseY, e.deltaY < 0 ? 1.1 : 0.9);
        }
        
        CanvasManager.render();
      },

      /*
       * Zoom at a specific screen position
      */
      zoomAt(screenX, screenY, zoomFactor) {
        const { canvas, scale, originX, originY } = AppState;
        
        // Calculate world coordinates under cursor
        const wx = (screenX - canvas.width / 2) / scale + originX;
        const wy = (screenY - canvas.height / 2) / scale + originY;
        
        // Apply zoom
        AppState.scale *= zoomFactor;
        
        // Adjust origin to keep world coords under cursor
        AppState.originX = wx - (screenX - canvas.width / 2) / AppState.scale;
        AppState.originY = wy - (screenY - canvas.height / 2) / AppState.scale;
      },

      /*
       * Handle touch start event
      */
      handleTouchStart(e) {
        e.preventDefault();
        AppState.userInteracted = true;
        
        // Store all touches
        AppState.touches = {};
        for (let i = 0; i < e.touches.length; i++) {
          const touch = e.touches[i];
          AppState.touches[touch.identifier] = { x: touch.clientX, y: touch.clientY };
        }
        
        if (e.touches.length === 2) {
          // Two finger touch - prepare for pinch zoom
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const dx = touch2.clientX - touch1.clientX;
          const dy = touch2.clientY - touch1.clientY;
          
          AppState.initialDistance = Math.sqrt(dx * dx + dy * dy);
          AppState.initialScale = AppState.scale;
          AppState.touchStartOriginX = AppState.originX;
          AppState.touchStartOriginY = AppState.originY;
        }
      },

      /*
       * Handle touch move event
      */
      handleTouchMove(e) {
        e.preventDefault();
        
        if (e.touches.length === 1 && Object.keys(AppState.touches).length === 1) {
          // Single finger - pan
          const touch = e.touches[0];
          const oldTouch = AppState.touches[touch.identifier];
          
          if (oldTouch) {
            const dx = (touch.clientX - oldTouch.x) / AppState.scale;
            const dy = (touch.clientY - oldTouch.y) / AppState.scale;
            
            AppState.originX -= dx;
            AppState.originY -= dy;
            
            AppState.touches[touch.identifier] = { x: touch.clientX, y: touch.clientY };
            CanvasManager.render();
          }
        } else if (e.touches.length === 2) {
          // Two fingers - pinch zoom
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const dx = touch2.clientX - touch1.clientX;
          const dy = touch2.clientY - touch1.clientY;
          const currentDistance = Math.sqrt(dx * dx + dy * dy);
          
          if (AppState.initialDistance > 0) {
            const zoomFactor = currentDistance / AppState.initialDistance;
            AppState.scale = AppState.initialScale * zoomFactor;
            
            // Zoom towards center point between fingers
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            
            const { canvas, initialScale, touchStartOriginX, touchStartOriginY, scale } = AppState;
            const wx = (centerX - canvas.width / 2) / initialScale + touchStartOriginX;
            const wy = (centerY - canvas.height / 2) / initialScale + touchStartOriginY;
            
            AppState.originX = wx - (centerX - canvas.width / 2) / scale;
            AppState.originY = wy - (centerY - canvas.height / 2) / scale;
            
            CanvasManager.render();
          }
        }
      },

      /*
       * Handle touch end event
      */
      handleTouchEnd(e) {
        e.preventDefault();
        
        // Keep only remaining touches
        const remainingTouches = {};
        for (let i = 0; i < e.touches.length; i++) {
          const touch = e.touches[i];
          if (AppState.touches[touch.identifier]) {
            remainingTouches[touch.identifier] = AppState.touches[touch.identifier];
          }
        }
        AppState.touches = remainingTouches;
        
        if (e.touches.length < 2) {
          AppState.initialDistance = 0;
        }
      },

      /*
       * Handle touch cancel event
      */
      handleTouchCancel(e) {
        e.preventDefault();
        AppState.touches = {};
        AppState.initialDistance = 0;
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MESSAGE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const MessageSystem = {
      /*
       * Show a message in a form panel
      */
      show(mode, text, type = 'success') {
        const messageEl = Utils.$(`${mode}_message`);
        if (!messageEl) return;
        
        messageEl.textContent = text;
        messageEl.className = `form-message ${type}`;
        messageEl.style.display = 'block';
        
        // Clear any existing timeout
        if (AppState.messageTimeouts[mode]) {
          clearTimeout(AppState.messageTimeouts[mode]);
        }
        
        // Auto-hide after 3 seconds
        AppState.messageTimeouts[mode] = setTimeout(() => {
          this.hide(mode);
        }, 3000);
      },

      /*
       * Hide a message in a form panel
      */
      hide(mode) {
        const messageEl = Utils.$(`${mode}_message`);
        if (messageEl) {
          messageEl.style.display = 'none';
        }
        
        if (AppState.messageTimeouts[mode]) {
          clearTimeout(AppState.messageTimeouts[mode]);
          delete AppState.messageTimeouts[mode];
        }
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA MANAGER (Auto-save, Export, Import)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const DataManager = {
      /*
       * Prepare data for saving
      */
      prepareDataForSave() {
        const data = {
          config: AppState.config,
          generalMarks: AppState.generalMarks,
          sounds: AppState.sounds.map(s => {
            const soundData = {
              src: s.src,
              x1: s.x1,
              y1: s.y1,
              x2: s.x2,
              y2: s.y2,
              minScale: s.minScale
            };
            if (s.name) soundData.name = s.name;
            if (s.maxScale !== undefined) soundData.maxScale = s.maxScale;
            return soundData;
          }),
          gallery: AppState.gallery
        };
        
        // Validate data integrity
        if (!data.config || !Array.isArray(data.generalMarks) || 
            !Array.isArray(data.sounds) || !Array.isArray(data.gallery)) {
          throw new Error('Invalid data structure');
        }
        
        return data;
      },

      /*
       * Save data using File System Access API
      */
      async saveData() {
        let data, json;
        const autoSaveToggle = Utils.$('autoSaveToggle');
        
        try {
          data = this.prepareDataForSave();
        } catch (err) {
          console.error('Data preparation failed:', err);
          alert('Save failed: Data is corrupted or invalid. Autosave has been disabled.');
          AppState.autoSave = false;
          autoSaveToggle.classList.remove('active');
          autoSaveToggle.classList.add('disabled');
          return false;
        }
        
        try {
          json = JSON.stringify(data, null, 2);
        } catch (err) {
          console.error('JSON.stringify failed:', err);
          alert('Save failed: Data is too large. Use Download button instead or remove some images.');
          AppState.autoSave = false;
          autoSaveToggle.classList.remove('active');
          autoSaveToggle.classList.add('disabled');
          return false;
        }
        
        // Safety checks
        if (!json || json.length < 100) {
          console.error('Generated JSON is suspiciously small:', json.length, 'bytes');
          alert('Save blocked: Generated data is too small and may be corrupted.');
          AppState.autoSave = false;
          autoSaveToggle.classList.remove('active');
          autoSaveToggle.classList.add('disabled');
          return false;
        }
        
        const estimatedSize = json.length * 1.2;
        const maxSafeSize = 500 * 1024 * 1024; // 500MB
        if (estimatedSize > maxSafeSize) {
          console.error('Data is too large:', estimatedSize, 'bytes');
          alert('Save blocked: Data size exceeds safe limits.');
          AppState.autoSave = false;
          autoSaveToggle.classList.remove('active');
          autoSaveToggle.classList.add('disabled');
          return false;
        }
        
        // Try File System Access API
        if ('showSaveFilePicker' in window) {
          try {
            if (!AppState.fileHandle) {
              AppState.fileHandle = await window.showSaveFilePicker({
                suggestedName: 'map-data.json',
                types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }]
              });
            }
            
            const writable = await AppState.fileHandle.createWritable();
            await writable.write(json);
            await writable.close();
            
            console.log('File saved successfully!');
            AppState.hasUnsavedChanges = false;
            return true;
          } catch (err) {
            if (err.name !== 'AbortError') {
              console.error('Save error:', err);
              AppState.fileHandle = null;
              AppState.autoSave = false;
              autoSaveToggle.classList.remove('active');
              alert('Save failed. Please re-enable autosave and select file again.');
            }
            return false;
          }
        } else {
          console.warn('File System Access API not supported. Autosave disabled.');
          AppState.autoSave = false;
          autoSaveToggle.classList.remove('active');
          this.fallbackDownload(json);
          return true;
        }
      },

      /*
       * Download file as fallback
      */
      fallbackDownload(json) {
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'map-data.json';
        a.click();
        
        setTimeout(() => URL.revokeObjectURL(url), 100);
        AppState.hasUnsavedChanges = false;
      },

      /*
       * Trigger auto-save with debouncing
      */
      triggerAutoSave() {
        AppState.hasUnsavedChanges = true;
        
        if (AppState.autoSave) {
          clearTimeout(AppState.autoSaveTimeout);
          AppState.autoSaveTimeout = setTimeout(() => {
            this.saveData();
          }, 2000);
        }
      },

      /*
       * Load data from JSON file
      */
      async loadFromJSON() {
        try {
          const response = await fetch('data/map-data.json');
          if (!response.ok) throw new Error('Failed to load map data');
          
          const data = await response.json();
          
          // Load gallery first
          if (data.gallery && Array.isArray(data.gallery)) {
            AppState.gallery = data.gallery;
          }
          
          // Load and convert config
          if (data.config && Array.isArray(data.config)) {
            AppState.config = data.config;
            this.convertLegacyFormat(AppState.config);
            AppState.config.forEach(node => ImageSystem.loadImages(node));
          }
          
          // Load general marks
          if (data.generalMarks && Array.isArray(data.generalMarks)) {
            data.generalMarks.forEach(mark => AppState.generalMarks.push(mark));
          }
          
          // Load sounds
          if (data.sounds && Array.isArray(data.sounds)) {
            data.sounds.forEach(s => {
              let src = s.src || s.url;
              if (s.galleryId && !src.startsWith('gallery:')) {
                src = `gallery:${s.galleryId}`;
              }
              
              const audioSrc = Utils.resolveGalleryUrl(src);
              
              const sound = {
                src,
                x1: s.x1,
                y1: s.y1,
                x2: s.x2,
                y2: s.y2,
                minScale: s.minScale,
                audio: new Audio(audioSrc),
                playing: false
              };
              
              if (s.name) sound.name = s.name;
              if (s.maxScale !== undefined) sound.maxScale = s.maxScale;
              sound.audio.loop = true;
              sound.audio.volume = 1;
              AppState.sounds.push(sound);
            });
          }
          
          MarkSystem.initialize();
          return true;
        } catch (error) {
          console.error('Error loading data:', error);
          return false;
        }
      },

      /*
       * Convert legacy data format (url/galleryId to src)
      */
      convertLegacyFormat(nodes) {
        nodes.forEach(node => {
          if (node.url && !node.src) {
            node.src = node.url;
            delete node.url;
          }
          if (node.galleryId && !node.src?.startsWith('gallery:')) {
            node.src = `gallery:${node.galleryId}`;
            delete node.galleryId;
          }
          if (node.children) {
            this.convertLegacyFormat(node.children);
          }
        });
      },

      /*
       * Handle file upload for data import
      */
      handleUpload(file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            
            // Stop all sounds
            SoundSystem.stopAll();
            
            // Remove mark elements
            AppState.marks.forEach(m => {
              if (m.element?.parentNode) {
                m.element.parentNode.removeChild(m.element);
              }
            });
            
            // Clear all data
            AppState.config.length = 0;
            AppState.generalMarks.length = 0;
            AppState.sounds.length = 0;
            AppState.marks.length = 0;
            AppState.gallery.length = 0;
            
            // Load gallery first
            if (data.gallery && Array.isArray(data.gallery)) {
              data.gallery.forEach(item => AppState.gallery.push(item));
            }
            
            // Load config
            if (data.config && Array.isArray(data.config)) {
              data.config.forEach(node => AppState.config.push(node));
              this.convertLegacyFormat(AppState.config);
              AppState.config.forEach(node => ImageSystem.loadImages(node));
            }
            
            // Load general marks
            if (data.generalMarks && Array.isArray(data.generalMarks)) {
              data.generalMarks.forEach(mark => AppState.generalMarks.push(mark));
            }
            
            // Load sounds
            if (data.sounds && Array.isArray(data.sounds)) {
              data.sounds.forEach(s => {
                let src = s.src || s.url;
                if (s.galleryId && !src.startsWith('gallery:')) {
                  src = `gallery:${s.galleryId}`;
                }
                
                const audioSrc = Utils.resolveGalleryUrl(src);
                
                const sound = {
                  src,
                  x1: s.x1,
                  y1: s.y1,
                  x2: s.x2,
                  y2: s.y2,
                  minScale: s.minScale,
                  audio: new Audio(audioSrc),
                  playing: false
                };
                
                if (s.maxScale !== undefined) sound.maxScale = s.maxScale;
                sound.audio.loop = true;
                sound.audio.volume = 1;
                AppState.sounds.push(sound);
              });
            }
            
            // Rebuild marks
            AppState.config.forEach(node => MarkSystem.collectMarks(node));
            AppState.generalMarks.forEach(gm => {
              AppState.marks.push({
                node: gm,
                element: null,
                isGeneral: true
              });
            });
            
            CanvasManager.render();
            EditModeController.populateNodeSelects();
            alert('Data loaded successfully!');
          } catch (error) {
            alert('Error loading data: ' + error.message);
          }
        };
        reader.readAsText(file);
      }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SEARCH FILTER CONTROLLER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const SearchController = {
      /*
       * Filter image list based on search
      */
      filterImages() {
        const searchTerm = Utils.$('img_search').value.toLowerCase();
        const showChildren = Utils.$('img_show_children').checked;
        const items = Utils.$$('#img_delete_list .delete-item');
        const isSearching = searchTerm.trim() !== '';
        
        // First pass: find matches
        const matchedPaths = new Set();
        items.forEach(item => {
          const text = item.querySelector('.delete-item-text').textContent.toLowerCase();
          if (text.includes(searchTerm)) {
            matchedPaths.add(item.getAttribute('data-path'));
          }
        });
        
        // Second pass: show/hide based on matches
        items.forEach(item => {
          const text = item.querySelector('.delete-item-text').textContent.toLowerCase();
          const matches = text.includes(searchTerm);
          const itemPath = item.getAttribute('data-path');
          
          let isDescendant = false;
          if (showChildren) {
            for (const matchedPath of matchedPaths) {
              if (itemPath.startsWith(matchedPath + ',')) {
                isDescendant = true;
                break;
              }
            }
          }
          
          const shouldShow = !isSearching || matches || isDescendant;
          item.style.display = shouldShow ? 'flex' : 'none';
          
          // Toggle dragging
          const handle = item.querySelector('.delete-item-drag-handle');
          if (isSearching) {
            item.classList.remove('draggable');
            item.draggable = false;
            if (handle) handle.style.display = 'none';
          } else {
            item.classList.add('draggable');
            item.draggable = true;
            if (handle) handle.style.display = '';
          }
        });
      },

      /*
       * Filter mark list based on search
      */
      filterMarks() {
        const searchTerm = Utils.$('mark_search').value.toLowerCase();
        const items = Utils.$$('#mark_delete_list .delete-item');
        const isSearching = searchTerm.trim() !== '';
        
        items.forEach(item => {
          const text = item.querySelector('.delete-item-text').textContent.toLowerCase();
          const matches = text.includes(searchTerm);
          
          const shouldShow = !isSearching || matches;
          item.style.display = shouldShow ? 'flex' : 'none';
          
          const handle = item.querySelector('.delete-item-drag-handle');
          if (isSearching) {
            item.classList.remove('draggable');
            item.draggable = false;
            if (handle) handle.style.display = 'none';
          } else if (item.getAttribute('data-type') === 'general') {
            item.classList.add('draggable');
            item.draggable = true;
            if (handle) handle.style.display = '';
          }
        });
      },

      /*
       * Filter sound list based on search
      */
      filterSounds() {
        const searchTerm = Utils.$('sound_search').value.toLowerCase();
        const showChildren = Utils.$('sound_show_children').checked;
        const items = Utils.$$('#sound_delete_list .delete-item');
        const isSearching = searchTerm.trim() !== '';
        
        const matchedPaths = new Set();
        items.forEach(item => {
          const text = item.querySelector('.delete-item-text').textContent.toLowerCase();
          if (text.includes(searchTerm)) {
            const path = item.getAttribute('data-path');
            if (path) matchedPaths.add(path);
          }
        });
        
        items.forEach(item => {
          const text = item.querySelector('.delete-item-text').textContent.toLowerCase();
          const matches = text.includes(searchTerm);
          const itemPath = item.getAttribute('data-path');
          
          let isDescendant = false;
          if (showChildren && itemPath) {
            for (const matchedPath of matchedPaths) {
              if (itemPath.startsWith(matchedPath + ',')) {
                isDescendant = true;
                break;
              }
            }
          }
          
          const shouldShow = !isSearching || matches || isDescendant;
          item.style.display = shouldShow ? 'flex' : 'none';
          
          const handle = item.querySelector('.delete-item-drag-handle');
          if (isSearching) {
            item.classList.remove('draggable');
            item.draggable = false;
            if (handle) handle.style.display = 'none';
          } else {
            item.classList.add('draggable');
            item.draggable = true;
            if (handle) handle.style.display = '';
          }
        });
      },

      /*
       * Initialize search event listeners
      */
      init() {
        Utils.$('img_search').addEventListener('input', () => this.filterImages());
        Utils.$('img_show_children').addEventListener('change', () => this.filterImages());
        Utils.$('mark_search').addEventListener('input', () => this.filterMarks());
        Utils.$('sound_search').addEventListener('input', () => this.filterSounds());
        Utils.$('sound_show_children').addEventListener('change', () => this.filterSounds());
      }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EDIT MODE CONTROLLER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const EditModeController = {
      elements: {},

      /*
       * Initialize edit mode controller
      */
      init() {
        this.elements = {
          editModeBtn: Utils.$('editModeBtn'),
          editSidebar: Utils.$('editSidebar'),
          modeTabs: Utils.$$('.mode-tab'),
          modeContents: Utils.$$('.mode-content'),
          autoSaveToggle: Utils.$('autoSaveToggle'),
          toggleMarks: Utils.$('toggleMarks'),
          toggleSounds: Utils.$('toggleSounds')
        };

        this.setupEventListeners();
        this.setupPickButtons();
        this.setupFileDropZones();
        this.setupFormButtons();
        this.setupDataManagement();
        this.setupAutoSave();
      },

      /*
       * Setup main event listeners
      */
      setupEventListeners() {
        const { editModeBtn, editSidebar, autoSaveToggle, toggleMarks, toggleSounds, modeTabs } = this.elements;
        
        // Toggle edit mode
        editModeBtn.addEventListener('click', () => {
          AppState.editMode = !AppState.editMode;
          editModeBtn.classList.toggle('active');
          editSidebar.classList.toggle('active');
          
          if (!AppState.editMode) {
            AppState.pickingCoord = null;
            AppState.canvas.classList.remove('picking');
            Utils.$$('.pick-btn').forEach(btn => btn.classList.remove('active'));
          }
          
          autoSaveToggle.classList.toggle('visible', AppState.editMode);
          CanvasManager.render();
        });

        // Toggle marks visibility
        toggleMarks.addEventListener('click', (e) => {
          AppState.markMode = (AppState.markMode + 1) % 4;
          
          const icons = ['ğŸ“', 'ğŸ‘º', 'ğŸ—ºï¸', 'ğŸ“'];
          e.target.textContent = icons[AppState.markMode];
          e.target.classList.toggle('active', AppState.markMode !== 3);
          
          CanvasManager.render();
        });

        // Toggle sounds visibility
        toggleSounds.addEventListener('click', (e) => {
          AppState.showSounds = !AppState.showSounds;
          e.target.classList.toggle('active');
          e.target.textContent = AppState.showSounds ? 'ğŸ”Š' : 'ğŸ”‡';
          
          if (!AppState.showSounds) {
            SoundSystem.stopAll();
          }
          CanvasManager.render();
        });

        // Mode tab switching
        modeTabs.forEach(tab => {
          tab.addEventListener('click', () => this.switchMode(tab.dataset.mode));
        });

        // Canvas click for coordinate picking and editing
        AppState.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));

        // Mark type change
        Utils.$('mark_type').addEventListener('change', (e) => {
          const isGeneral = e.target.value === 'general';
          Utils.$('mark_node_section').style.display = isGeneral ? 'none' : 'block';
          Utils.$('mark_general_section').classList.toggle('visible', isGeneral);
        });
      },

      /*
       * Switch between edit modes
      */
      switchMode(mode) {
        if (mode === 'gallery') {
          GalleryManager.open('image', true);
          return;
        }

        // Check for unsaved changes
        if (this.hasFormChanges()) {
          if (!confirm('Hai modifiche non salvate. Vuoi resettare e cambiare modalitÃ ?')) {
            return;
          }
          this.resetCurrentForm();
        }

        AppState.currentMode = mode;
        
        // Update UI
        this.elements.modeTabs.forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
        this.elements.modeContents.forEach(c => {
          c.classList.toggle('active', c.id === mode + 'Mode');
        });

        // Clear picking state
        AppState.pickingCoord = null;
        AppState.canvas.classList.remove('picking');
        Utils.$$('.pick-btn').forEach(btn => btn.classList.remove('active'));
        
        // Hide messages
        ['img', 'mark', 'sound'].forEach(m => MessageSystem.hide(m));
        
        CanvasManager.render();
        
        // Reset forms
        this.resetForm(mode);
        
        if (mode === 'mark' || mode === 'image') {
          this.populateNodeSelects();
        }
      },

      /*
       * Reset form for a specific mode
      */
      resetForm(mode) {
        if (mode === 'image') {
          this.resetImageForm();
        } else if (mode === 'mark') {
          this.resetMarkForm();
        } else if (mode === 'sound') {
          this.resetSoundForm();
        }
      },

      /*
       * Reset current form based on editing state
      */
      resetCurrentForm() {
        if (AppState.editingNodePath) {
          Utils.$('img_clear').click();
        } else if (AppState.editingMarkData) {
          Utils.$('mark_clear').click();
        } else if (AppState.editingSoundIndex !== null) {
          Utils.$('sound_clear').click();
        }
      },

      /*
       * Reset image form
      */
      resetImageForm() {
        Utils.$('img_name').value = '';
        Utils.$('img_url').value = '';
        Utils.$('img_x').value = '';
        Utils.$('img_y').value = '';
        Utils.$('img_appearScale').value = '0';
        Utils.$('img_size').value = '1';
        Utils.$('img_parent').value = '';
        Utils.$('img_preview').style.display = 'none';
        Utils.$('img_file_input').value = '';
        Utils.$('img_url').style.borderColor = '';
        
        AppState.editingNodePath = null;
        AppState.backupImageData = null;
        
        const btn = Utils.$('img_add');
        btn.textContent = 'Add Image';
        btn.classList.remove('btn-warning');
        btn.classList.add('btn-primary');
        
        Utils.$('img_update_children_wrapper').classList.add('hidden');
      },

      /*
       * Reset mark form
      */
      resetMarkForm() {
        Utils.$('mark_node').value = '';
        Utils.$('mark_x').value = '';
        Utils.$('mark_y').value = '';
        Utils.$('mark_parent').value = '';
        Utils.$('mark_markType').value = '';
        Utils.$('mark_name').value = '';
        Utils.$('mark_description').value = '';
        Utils.$('mark_type').disabled = false;
        Utils.$('mark_node').disabled = false;
        
        AppState.editingMarkData = null;
        AppState.backupMarkData = null;
        
        const btn = Utils.$('mark_add');
        btn.textContent = 'Add Mark';
        btn.classList.remove('btn-warning');
        btn.classList.add('btn-primary');
      },

      /*
       * Reset sound form
      */
      resetSoundForm() {
        Utils.$('sound_name').value = '';
        Utils.$('sound_url').value = '';
        Utils.$('sound_x1').value = '';
        Utils.$('sound_y1').value = '';
        Utils.$('sound_x2').value = '';
        Utils.$('sound_y2').value = '';
        Utils.$('sound_minScale').value = '0';
        Utils.$('sound_maxScale').value = '';
        Utils.$('sound_url').style.borderColor = '';
        
        AppState.editingSoundIndex = null;
        AppState.backupSoundData = null;
        
        const btn = Utils.$('sound_add');
        btn.textContent = 'Add Sound';
        btn.classList.remove('btn-warning');
        btn.classList.add('btn-primary');
      },

      /*
       * Check if form has unsaved changes
      */
      hasFormChanges() {
        const { editingNodePath, editingMarkData, editingSoundIndex,
                backupImageData, backupMarkData, backupSoundData } = AppState;
        
        if (editingNodePath && backupImageData) {
          const name = Utils.$('img_name').value.trim();
          const url = Utils.$('img_url').value.trim();
          const x = parseFloat(Utils.$('img_x').value);
          const y = parseFloat(Utils.$('img_y').value);
          const appearScale = parseFloat(Utils.$('img_appearScale').value);
          const size = parseFloat(Utils.$('img_size').value);
          
          return name !== backupImageData.name ||
                 url !== backupImageData.src ||
                 x !== backupImageData.x ||
                 y !== backupImageData.y ||
                 appearScale !== backupImageData.appearScale ||
                 size !== backupImageData.size;
        }
        
        if (editingMarkData && backupMarkData) {
          const markType = Utils.$('mark_markType').value;
          const markDescription = Utils.$('mark_description').value.trim();
          
          if (editingMarkData.type === 'node') {
            return markType !== (backupMarkData.markType || '') ||
                   markDescription !== backupMarkData.mark;
          } else {
            const x = parseFloat(Utils.$('mark_x').value);
            const y = parseFloat(Utils.$('mark_y').value);
            const name = Utils.$('mark_name').value.trim();
            
            return x !== backupMarkData.x ||
                   y !== backupMarkData.y ||
                   markType !== (backupMarkData.markType || '') ||
                   name !== backupMarkData.name ||
                   markDescription !== backupMarkData.mark;
          }
        }
        
        if (editingSoundIndex !== null && backupSoundData) {
          const name = Utils.$('sound_name').value.trim();
          const url = Utils.$('sound_url').value.trim();
          const x1 = parseFloat(Utils.$('sound_x1').value);
          const y1 = parseFloat(Utils.$('sound_y1').value);
          const x2 = parseFloat(Utils.$('sound_x2').value);
          const y2 = parseFloat(Utils.$('sound_y2').value);
          const minScale = parseFloat(Utils.$('sound_minScale').value);
          const maxScale = Utils.$('sound_maxScale').value.trim();
          
          return name !== (backupSoundData.name || '') ||
                 url !== backupSoundData.src ||
                 x1 !== backupSoundData.x1 ||
                 y1 !== backupSoundData.y1 ||
                 x2 !== backupSoundData.x2 ||
                 y2 !== backupSoundData.y2 ||
                 minScale !== backupSoundData.minScale ||
                 maxScale !== (backupSoundData.maxScale || '');
        }
        
        return false;
      },

      /*
       * Populate node select dropdowns
      */
      populateNodeSelects(excludeNodePath = null) {
        const imgParentSelect = Utils.$('img_parent');
        const markNodeSelect = Utils.$('mark_node');
        const markParentSelect = Utils.$('mark_parent');
        
        imgParentSelect.innerHTML = '<option value="">None (Root Level)</option>';
        markNodeSelect.innerHTML = '<option value="">Choose a node...</option>';
        markParentSelect.innerHTML = '<option value="">None (Always visible)</option>';
        
        // Collect all descendant paths if excluding a node
        const excludedPaths = new Set();
        if (excludeNodePath) {
          excludedPaths.add(excludeNodePath);
          const excludedNode = Utils.getNodeByPath(excludeNodePath);
          if (excludedNode) {
            const collectDescendants = (node, basePath) => {
              if (node.children?.length) {
                node.children.forEach((child, index) => {
                  const childPath = basePath + ',' + index;
                  excludedPaths.add(childPath);
                  collectDescendants(child, childPath);
                });
              }
            };
            collectDescendants(excludedNode, excludeNodePath);
          }
        }
        
        const addNodeOptions = (nodes, prefix = '', parentPath = []) => {
          nodes.forEach((node, index) => {
            const path = [...parentPath, index];
            const pathStr = path.join(',');
            const displayName = node.name || (node.src ? node.src.split('/').pop().replace('gallery:', '') : 'Node');
            const label = prefix + Utils.getGalleryItemName(displayName);
            
            [imgParentSelect, markNodeSelect, markParentSelect].forEach(select => {
              const option = document.createElement('option');
              option.value = pathStr;
              option.textContent = label;
              
              // Disable circular references in img_parent select
              if (select === imgParentSelect && excludedPaths.has(pathStr)) {
                option.disabled = true;
                if (pathStr === excludeNodePath) {
                  option.textContent = label + ' (current image)';
                } else {
                  option.textContent = label + ' (would create loop)';
                }
              }
              
              select.appendChild(option);
            });
            
            if (node.children?.length) {
              addNodeOptions(node.children, prefix + '  ', path);
            }
          });
        };
        
        addNodeOptions(AppState.config);
        this.updateAllDeleteLists();
      },

      /*
       * Update all delete lists
      */
      updateAllDeleteLists() {
        this.updateImageDeleteList();
        this.updateMarkDeleteList();
        this.updateSoundDeleteList();
      },

      /*
       * Update image delete list
      */
      updateImageDeleteList() {
        const list = Utils.$('img_delete_list');
        list.innerHTML = '';
        
        const addImageItems = (nodes, prefix = '', parentPath = [], depth = 0) => {
          nodes.forEach((node, index) => {
            const path = [...parentPath, index];
            const pathStr = path.join(',');
            const parentPathStr = parentPath.join(',');
            
            const indent = depth > 0 ? '&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(depth - 1) + 'â¤·&nbsp;' : '';
            const nodeName = node.name || (node.src ? node.src.split('/').pop().replace('gallery:', '') : 'Node');
            const label = indent + Utils.getGalleryItemName(nodeName);
            
            const item = document.createElement('div');
            item.className = 'delete-item';
            item.setAttribute('data-path', pathStr);
            item.setAttribute('data-depth', depth);
            item.setAttribute('data-parent-path', parentPathStr);
            item.innerHTML = `
              <div class="delete-item-text" title="${nodeName}">${label}</div>
              <button class="delete-btn-small btn-edit" data-path="${pathStr}" data-action="edit">Edit</button>
              <button class="delete-btn-small" data-path="${pathStr}" data-action="delete">Delete</button>
            `;
            list.appendChild(item);
            
            DragDropController.makeItemDraggable(item, index, { path: pathStr, depth, parentPath: parentPathStr }, 'img');
            
            if (node.children?.length) {
              addImageItems(node.children, prefix + '  ', path, depth + 1);
            }
          });
        };
        
        if (AppState.config.length === 0) {
          list.innerHTML = '<div class="empty-list">No images available</div>';
        } else {
          addImageItems(AppState.config);
          
          list.querySelectorAll('.delete-btn-small').forEach(btn => {
            btn.addEventListener('click', () => {
              if (btn.dataset.action === 'edit') {
                this.loadNodeForEdit(btn.dataset.path);
              } else if (btn.dataset.action === 'delete') {
                if (confirm('Are you sure you want to delete this image and all its children?')) {
                  Utils.deleteNodeByPath(btn.dataset.path);
                  this.populateNodeSelects();
                  CanvasManager.render();
                  DataManager.triggerAutoSave();
                }
              }
            });
          });
          
          DragDropController.setupDragAndDrop(list, 'img');
        }
      },

      /*
       * Update mark delete list
      */
      updateMarkDeleteList() {
        const list = Utils.$('mark_delete_list');
        list.innerHTML = '';
        
        let hasMarks = false;
        
        // Add node marks
        const addNodeMarks = (nodes, prefix = '', parentPath = []) => {
          nodes.forEach((node, index) => {
            const path = [...parentPath, index];
            const pathStr = path.join(',');
            
            if (node.mark !== undefined) {
              hasMarks = true;
              const displayName = node.name || (node.src ? node.src.split('/').pop().replace('gallery:', '') : 'Node');
              const label = prefix + Utils.getGalleryItemName(displayName);
              
              const item = document.createElement('div');
              item.className = 'delete-item';
              item.innerHTML = `
                <div class="delete-item-text" title="${label}">${label}</div>
                <button class="delete-btn-small btn-edit" data-path="${pathStr}" data-type="node" data-action="edit">Edit</button>
                <button class="delete-btn-small" data-path="${pathStr}" data-type="node" data-action="delete">Delete</button>
              `;
              list.appendChild(item);
            }
            
            if (node.children?.length) {
              addNodeMarks(node.children, prefix + '  ', path);
            }
          });
        };
        
        addNodeMarks(AppState.config);
        
        // Add general marks
        AppState.generalMarks.forEach((mark, index) => {
          hasMarks = true;
          const label = mark.name ? `${mark.name} at (${mark.x}, ${mark.y})` : `General Mark at (${mark.x}, ${mark.y})`;
          
          const item = document.createElement('div');
          item.className = 'delete-item';
          item.setAttribute('data-index', index);
          item.setAttribute('data-type', 'general');
          item.innerHTML = `
            <div class="delete-item-text" title="${label}">${label}</div>
            <button class="delete-btn-small btn-edit" data-index="${index}" data-type="general" data-action="edit">Edit</button>
            <button class="delete-btn-small" data-index="${index}" data-type="general" data-action="delete">Delete</button>
          `;
          list.appendChild(item);
          
          DragDropController.makeItemDraggable(item, index, { isGeneral: true }, 'mark');
        });
        
        if (!hasMarks) {
          list.innerHTML = '<div class="empty-list">No marks available</div>';
        } else {
          list.querySelectorAll('.delete-btn-small').forEach(btn => {
            btn.addEventListener('click', () => {
              if (btn.dataset.action === 'edit') {
                if (btn.dataset.type === 'node') {
                  this.loadMarkForEdit('node', btn.dataset.path);
                } else {
                  this.loadMarkForEdit('general', parseInt(btn.dataset.index));
                }
              } else if (btn.dataset.action === 'delete') {
                if (confirm('Are you sure you want to delete this mark?')) {
                  if (btn.dataset.type === 'node') {
                    const node = Utils.getNodeByPath(btn.dataset.path);
                    if (node) {
                      delete node.mark;
                      delete node.markType;
                      delete node.name;
                    }
                  } else {
                    AppState.generalMarks.splice(parseInt(btn.dataset.index), 1);
                  }
                  
                  MarkSystem.rebuildMarks();
                  this.updateAllDeleteLists();
                  CanvasManager.render();
                  DataManager.triggerAutoSave();
                }
              }
            });
          });
          
          DragDropController.setupDragAndDrop(list, 'mark');
        }
      },

      /*
       * Update sound delete list
      */
      updateSoundDeleteList() {
        const list = Utils.$('sound_delete_list');
        list.innerHTML = '';
        
        if (AppState.sounds.length === 0) {
          list.innerHTML = '<div class="empty-list">No sounds available</div>';
        } else {
          AppState.sounds.forEach((sound, index) => {
            const soundName = sound.name || (sound.src ? sound.src.split('/').pop().replace('gallery:', '') : 'Sound');
            const label = Utils.getGalleryItemName(soundName);
            
            const item = document.createElement('div');
            item.className = 'delete-item';
            item.setAttribute('data-index', index);
            item.innerHTML = `
              <div class="delete-item-text" title="${label}">${label}</div>
              <button class="delete-btn-small btn-edit" data-index="${index}" data-action="edit">Edit</button>
              <button class="delete-btn-small" data-index="${index}" data-action="delete">Delete</button>
            `;
            list.appendChild(item);
            
            DragDropController.makeItemDraggable(item, index, {}, 'sound');
          });
          
          list.querySelectorAll('.delete-btn-small').forEach(btn => {
            btn.addEventListener('click', () => {
              if (btn.dataset.action === 'edit') {
                this.loadSoundForEdit(parseInt(btn.dataset.index));
              } else if (btn.dataset.action === 'delete') {
                if (confirm('Are you sure you want to delete this sound?')) {
                  const index = parseInt(btn.dataset.index);
                  if (AppState.sounds[index].playing) {
                    AppState.sounds[index].audio.pause();
                  }
                  AppState.sounds.splice(index, 1);
                  this.updateAllDeleteLists();
                  CanvasManager.render();
                  DataManager.triggerAutoSave();
                }
              }
            });
          });
          
          DragDropController.setupDragAndDrop(list, 'sound');
        }
      },

      /*
       * Load a node for editing
      */
      loadNodeForEdit(path) {
        if (this.hasFormChanges()) {
          if (!confirm('Hai modifiche non salvate. Vuoi resettare e caricare un altro elemento?')) {
            return;
          }
        }
        
        const node = Utils.getNodeByPath(path);
        if (!node) return;
        
        AppState.editingNodePath = path;
        const indices = path.split(',').map(Number);
        const originalParentPath = indices.length > 1 ? indices.slice(0, -1).join(',') : '';
        AppState.backupImageData = {
          name: node.name || '',
          src: node.src || '',
          x: node.x,
          y: node.y,
          appearScale: node.appearScale,
          size: node.size,
          parentPath: originalParentPath
        };
        
        // Switch to image mode
        this.elements.modeTabs.forEach(t => t.classList.toggle('active', t.dataset.mode === 'image'));
        this.elements.modeContents.forEach(c => c.classList.toggle('active', c.id === 'imageMode'));
        AppState.currentMode = 'image';
        
        // Populate form
        Utils.$('img_name').value = node.name || '';
        Utils.$('img_url').value = node.src || '';
        Utils.$('img_x').value = node.x;
        Utils.$('img_y').value = node.y;
        Utils.$('img_appearScale').value = node.appearScale;
        Utils.$('img_size').value = node.size;
        
        if (node.src) {
          FileUploadHandler.updateImagePreview(node.src);
        }
        
        // Set parent
        this.populateNodeSelects(path);  // Exclude current node from parent dropdown
        Utils.$('img_parent').value = originalParentPath;
        
        // Update button
        const addBtn = Utils.$('img_add');
        addBtn.textContent = 'Update Image';
        addBtn.classList.remove('btn-primary');
        addBtn.classList.add('btn-warning');
        
        Utils.$('img_update_children_wrapper').classList.remove('hidden');
        Utils.$('editSidebar').scrollTop = 0;
      },

      /*
       * Load a mark for editing
      */
      loadMarkForEdit(type, pathOrIndex) {
        if (this.hasFormChanges()) {
          if (!confirm('Hai modifiche non salvate. Vuoi resettare e caricare un altro elemento?')) {
            return;
          }
        }
        
        let markData;
        if (type === 'node') {
          const node = Utils.getNodeByPath(pathOrIndex);
          if (!node || node.mark === undefined) return;
          markData = node;
          AppState.editingMarkData = { type: 'node', path: pathOrIndex };
        } else {
          markData = AppState.generalMarks[pathOrIndex];
          if (!markData) return;
          AppState.editingMarkData = { type: 'general', index: pathOrIndex };
        }
        
        // Backup
        if (type === 'node') {
          AppState.backupMarkData = {
            markType: markData.markType || '',
            mark: markData.mark || ''
          };
        } else {
          AppState.backupMarkData = {
            x: markData.x,
            y: markData.y,
            parentPath: markData.parentPath || '',
            markType: markData.markType || '',
            name: markData.name || '',
            mark: markData.mark || ''
          };
        }
        
        // Switch to mark mode
        this.elements.modeTabs.forEach(t => t.classList.toggle('active', t.dataset.mode === 'mark'));
        this.elements.modeContents.forEach(c => c.classList.toggle('active', c.id === 'markMode'));
        AppState.currentMode = 'mark';
        
        // Populate form
        Utils.$('mark_type').value = type;
        Utils.$('mark_type').dispatchEvent(new Event('change'));
        Utils.$('mark_type').disabled = true;
        
        if (type === 'node') {
          Utils.$('mark_node').value = pathOrIndex;
          Utils.$('mark_node').disabled = true;
        } else {
          Utils.$('mark_x').value = markData.x;
          Utils.$('mark_y').value = markData.y;
          Utils.$('mark_parent').value = markData.parentPath || '';
        }
        
        Utils.$('mark_markType').value = markData.markType || '';
        if (type === 'general') {
          Utils.$('mark_name').value = markData.name || '';
        }
        Utils.$('mark_description').value = markData.mark || '';
        
        const addBtn = Utils.$('mark_add');
        addBtn.textContent = 'Update Mark';
        addBtn.classList.remove('btn-primary');
        addBtn.classList.add('btn-warning');
        
        Utils.$('editSidebar').scrollTop = 0;
      },

      /*
       * Load a sound for editing
      */
      loadSoundForEdit(index) {
        if (this.hasFormChanges()) {
          if (!confirm('Hai modifiche non salvate. Vuoi resettare e caricare un altro elemento?')) {
            return;
          }
        }
        
        const sound = AppState.sounds[index];
        if (!sound) return;
        
        AppState.editingSoundIndex = index;
        AppState.backupSoundData = {
          name: sound.name || '',
          src: sound.src,
          x1: sound.x1,
          y1: sound.y1,
          x2: sound.x2,
          y2: sound.y2,
          minScale: sound.minScale,
          maxScale: sound.maxScale || ''
        };
        
        // Switch to sound mode
        this.elements.modeTabs.forEach(t => t.classList.toggle('active', t.dataset.mode === 'sound'));
        this.elements.modeContents.forEach(c => c.classList.toggle('active', c.id === 'soundMode'));
        AppState.currentMode = 'sound';
        
        // Populate form
        Utils.$('sound_name').value = sound.name || '';
        Utils.$('sound_url').value = sound.src;
        Utils.$('sound_x1').value = sound.x1;
        Utils.$('sound_y1').value = sound.y1;
        Utils.$('sound_x2').value = sound.x2;
        Utils.$('sound_y2').value = sound.y2;
        Utils.$('sound_minScale').value = sound.minScale;
        Utils.$('sound_maxScale').value = sound.maxScale || '';
        
        const addBtn = Utils.$('sound_add');
        addBtn.textContent = 'Update Sound';
        addBtn.classList.remove('btn-primary');
        addBtn.classList.add('btn-warning');
        
        Utils.$('editSidebar').scrollTop = 0;
      },

      /*
       * Handle canvas click for picking and editing
      */
      handleCanvasClick(e) {
        if (!AppState.editMode) return;
        
        // Don't trigger if user was dragging
        if (AppState.hasDragged) {
          AppState.hasDragged = false;
          return;
        }
        
        // Handle coordinate picking
        if (AppState.pickingCoord) {
          e.stopPropagation();
          
          const world = Utils.screenToWorld(e.clientX, e.clientY);
          const worldX = world.x.toFixed(1);
          const worldY = world.y.toFixed(1);
          
          const pickMap = {
            'img_pick': ['img_x', 'img_y', RealTimeUpdater.updateImage],
            'mark_pick': ['mark_x', 'mark_y', RealTimeUpdater.updateMark],
            'sound_pick1': ['sound_x1', 'sound_y1', RealTimeUpdater.updateSound],
            'sound_pick2': ['sound_x2', 'sound_y2', RealTimeUpdater.updateSound]
          };
          
          const [xField, yField, updateFn] = pickMap[AppState.pickingCoord] || [];
          if (xField) {
            Utils.$(xField).value = worldX;
            Utils.$(yField).value = worldY;
            updateFn.call(RealTimeUpdater);
          }
          
          AppState.pickingCoord = null;
          AppState.canvas.classList.remove('picking');
          Utils.$$('.pick-btn').forEach(btn => btn.classList.remove('active'));
          return;
        }
        
        const { currentMode } = AppState;
        const world = Utils.screenToWorld(e.clientX, e.clientY);
        
        // Click to edit in image mode
        if (currentMode === 'image') {
          const clickedNode = ImageSystem.findNodeAtPosition(AppState.config, world.x, world.y);
          if (clickedNode) {
            this.loadNodeForEdit(clickedNode.path);
          }
        }
        
        // Click to edit in mark mode
        if (currentMode === 'mark') {
          const clickRadius = 30;
          let closestMark = null;
          let closestDist = clickRadius;
          
          for (const m of AppState.marks) {
            if (m.element && m.screenX && m.screenY) {
              const dx = e.clientX - m.screenX;
              const dy = e.clientY - m.screenY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < closestDist) {
                closestMark = m;
                closestDist = dist;
              }
            }
          }
          
          if (closestMark) {
            if (closestMark.isGeneral) {
              const index = AppState.generalMarks.indexOf(closestMark.node);
              if (index !== -1) this.loadMarkForEdit('general', index);
            } else {
              const path = Utils.findNodePath(AppState.config, closestMark.node);
              if (path) this.loadMarkForEdit('node', path);
            }
          }
        }
        
        // Click to edit in sound mode
        if (currentMode === 'sound') {
          const sortedSounds = [...AppState.sounds]
            .map((s, i) => ({ sound: s, index: i }))
            .sort((a, b) => (b.sound.minScale || 0) - (a.sound.minScale || 0));
          
          for (const { sound, index } of sortedSounds) {
            const minX = Math.min(sound.x1, sound.x2);
            const maxX = Math.max(sound.x1, sound.x2);
            const minY = Math.min(sound.y1, sound.y2);
            const maxY = Math.max(sound.y1, sound.y2);
            
            if (world.x >= minX && world.x <= maxX && world.y >= minY && world.y <= maxY) {
              this.loadSoundForEdit(index);
              break;
            }
          }
        }
      },

      /*
       * Setup pick buttons
      */
      setupPickButtons() {
        Utils.$$('.pick-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            if (AppState.pickingCoord === btn.id) {
              AppState.pickingCoord = null;
              AppState.canvas.classList.remove('picking');
              btn.classList.remove('active');
            } else {
              Utils.$$('.pick-btn').forEach(b => b.classList.remove('active'));
              AppState.pickingCoord = btn.id;
              AppState.canvas.classList.add('picking');
              btn.classList.add('active');
            }
          });
        });
      },

      /*
       * Setup file drop zones
      */
      setupFileDropZones() {
        FileUploadHandler.init();
      },

      /*
       * Setup form buttons
      */
      setupFormButtons() {
        FormHandler.init();
      },

      /*
       * Setup data management buttons
      */
      setupDataManagement() {
        Utils.$('data_download').addEventListener('click', () => {
          let data, json;
          
          try {
            data = DataManager.prepareDataForSave();
          } catch (err) {
            console.error('Data preparation failed:', err);
            alert('Download failed: Data is corrupted or invalid.');
            return;
          }
          
          try {
            json = JSON.stringify(data, null, 2);
          } catch (err) {
            console.error('JSON.stringify failed:', err);
            
            if (confirm('Data is too large. Download WITHOUT gallery items?')) {
              try {
                const dataWithoutGallery = { ...data, gallery: [] };
                json = JSON.stringify(dataWithoutGallery, null, 2);
                DataManager.fallbackDownload(json);
                alert('Downloaded successfully WITHOUT gallery.');
              } catch (err2) {
                alert('Download failed: Data is too large even without gallery.');
              }
            }
            return;
          }
          
          DataManager.fallbackDownload(json);
        });
        
        Utils.$('data_upload').addEventListener('click', () => {
          Utils.$('data_file').click();
        });
        
        Utils.$('data_file').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            // Disable auto-save before uploading new data
            if (AppState.autoSave) {
              AppState.autoSave = false;
              AppState.fileHandle = null;
              const autoSaveToggle = Utils.$('autoSaveToggle');
              autoSaveToggle.classList.remove('active');
            }
            
            DataManager.handleUpload(file);
          }
          e.target.value = '';
        });
      },

      /*
       * Setup auto-save toggle
      */
      setupAutoSave() {
        const autoSaveToggle = Utils.$('autoSaveToggle');
        
        autoSaveToggle.addEventListener('click', async () => {
          if (autoSaveToggle.classList.contains('disabled')) {
            alert('Autosave is disabled because your data is too large or corrupted.');
            return;
          }
          
          // Validate data before enabling
          if (!AppState.autoSave) {
            let data, json;
            try {
              data = DataManager.prepareDataForSave();
              json = JSON.stringify(data, null, 2);
            } catch (err) {
              alert('Cannot enable autosave: Data is corrupted or too large.');
              autoSaveToggle.classList.add('disabled');
              return;
            }
            
            if (!json || json.length < 50) {
              alert('Cannot enable autosave: Generated data appears corrupted.');
              autoSaveToggle.classList.add('disabled');
              return;
            }
            
            const estimatedSize = json.length * 1.2;
            const maxSafeSize = 500 * 1024 * 1024;
            if (estimatedSize > maxSafeSize) {
              alert(`Cannot enable autosave: Data size exceeds safe limits (${Math.round(estimatedSize / 1024 / 1024)}MB).`);
              autoSaveToggle.classList.add('disabled');
              return;
            }
          }
          
          AppState.autoSave = !AppState.autoSave;
          autoSaveToggle.classList.toggle('active');
          
          if (AppState.autoSave && 'showSaveFilePicker' in window) {
            try {
              AppState.fileHandle = await window.showSaveFilePicker({
                suggestedName: 'map-data.json',
                types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }]
              });
              await DataManager.saveData();
            } catch (err) {
              if (err.name === 'AbortError') {
                AppState.autoSave = false;
                autoSaveToggle.classList.remove('active');
              }
            }
          } else if (AppState.autoSave) {
            alert('Autosave is not supported in this browser.');
            AppState.autoSave = false;
            autoSaveToggle.classList.remove('active');
          }
        });
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // REAL-TIME UPDATER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const RealTimeUpdater = {
      /*
       * Update image in real-time during editing
      */
      updateImage() {
        if (!AppState.editingNodePath) return;
        const node = Utils.getNodeByPath(AppState.editingNodePath);
        if (!node) return;
        
        const name = Utils.$('img_name').value.trim();
        const url = Utils.$('img_url').value.trim();
        const x = parseFloat(Utils.$('img_x').value);
        const y = parseFloat(Utils.$('img_y').value);
        const appearScale = parseFloat(Utils.$('img_appearScale').value);
        const size = parseFloat(Utils.$('img_size').value);
        
        if (!url || isNaN(x) || isNaN(y) || isNaN(appearScale) || isNaN(size)) return;
        
        if (name) {
          node.name = name;
        } else {
          delete node.name;
        }
        node.src = url;
        node.x = x;
        node.y = y;
        node.appearScale = appearScale;
        node.size = size;
        
        ImageSystem.loadImages(node);
        CanvasManager.render();
      },

      /*
       * Update mark in real-time during editing
      */
      updateMark() {
        if (!AppState.editingMarkData) return;
        
        const markType = Utils.$('mark_markType').value;
        const markDescription = Utils.$('mark_description').value.trim();
        
        if (AppState.editingMarkData.type === 'node') {
          const node = Utils.getNodeByPath(AppState.editingMarkData.path);
          if (node) {
            if (markType) {
              node.markType = markType;
            } else {
              delete node.markType;
            }
            node.mark = markDescription;
            MarkSystem.rebuildMarks();
            CanvasManager.render();
          }
        } else {
          const mark = AppState.generalMarks[AppState.editingMarkData.index];
          if (mark) {
            const x = parseFloat(Utils.$('mark_x').value);
            const y = parseFloat(Utils.$('mark_y').value);
            const name = Utils.$('mark_name').value.trim();
            const parentPath = Utils.$('mark_parent').value;
            
            if (isNaN(x) || isNaN(y)) return;
            
            mark.x = x;
            mark.y = y;
            mark.name = name;
            if (parentPath) {
              mark.parentPath = parentPath;
            } else {
              delete mark.parentPath;
            }
            if (markType) {
              mark.markType = markType;
            } else {
              delete mark.markType;
            }
            mark.mark = markDescription;
            
            MarkSystem.rebuildMarks();
            CanvasManager.render();
          }
        }
      },

      /*
       * Update sound in real-time during editing
      */
      updateSound() {
        if (AppState.editingSoundIndex === null) return;
        const sound = AppState.sounds[AppState.editingSoundIndex];
        if (!sound) return;
        
        const name = Utils.$('sound_name').value.trim();
        const url = Utils.$('sound_url').value.trim();
        const x1 = parseFloat(Utils.$('sound_x1').value);
        const y1 = parseFloat(Utils.$('sound_y1').value);
        const x2 = parseFloat(Utils.$('sound_x2').value);
        const y2 = parseFloat(Utils.$('sound_y2').value);
        const minScale = parseFloat(Utils.$('sound_minScale').value);
        const maxScaleStr = Utils.$('sound_maxScale').value.trim();
        
        if (!url || isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) || isNaN(minScale)) return;
        
        if (name) {
          sound.name = name;
        } else {
          delete sound.name;
        }
        
        // Update URL and reload audio if URL changed
        if (sound.src !== url) {
          if (sound.playing) {
            sound.audio.pause();
          }
          sound.src = url;
          const audioSrc = Utils.resolveGalleryUrl(url);
          sound.audio = new Audio(audioSrc);
          sound.audio.loop = true;
          sound.audio.volume = 1;
          sound.playing = false;
        }
        
        sound.x1 = x1;
        sound.y1 = y1;
        sound.x2 = x2;
        sound.y2 = y2;
        sound.minScale = minScale;
        
        if (maxScaleStr) {
          const maxScale = parseFloat(maxScaleStr);
          if (!isNaN(maxScale)) {
            sound.maxScale = maxScale;
          }
        } else {
          delete sound.maxScale;
        }
        
        CanvasManager.render();
      },

      /*
       * Initialize real-time update listeners
      */
      init() {
        // Image mode listeners
        ['img_name', 'img_url', 'img_x', 'img_y', 'img_appearScale', 'img_size'].forEach(id => {
          Utils.$(id).addEventListener('input', () => this.updateImage());
        });
        
        // Mark mode listeners
        ['mark_x', 'mark_y', 'mark_markType', 'mark_name', 'mark_description', 'mark_parent'].forEach(id => {
          const eventType = (id === 'mark_markType' || id === 'mark_parent') ? 'change' : 'input';
          Utils.$(id).addEventListener(eventType, () => this.updateMark());
        });
        
        // Sound mode listeners
        ['sound_name', 'sound_url', 'sound_x1', 'sound_y1', 'sound_x2', 'sound_y2', 'sound_minScale', 'sound_maxScale'].forEach(id => {
          Utils.$(id).addEventListener('input', () => {
            this.updateSound();
            if (id === 'sound_url') {
              SoundSystem.update();
            }
          });
        });
      }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FILE UPLOAD HANDLER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const FileUploadHandler = {
      imgDropZone: null,
      imgFileInput: null,
      imgPreview: null,
      imgPreviewImg: null,
      imgFileInfo: null,
      imgUrlInput: null,
      soundDropZone: null,
      soundFileInput: null,
      soundPreview: null,
      soundFileInfo: null,
      soundUrlInput: null,

      /*
       * Initialize file upload handlers
      */
      init() {
        // Image elements
        this.imgDropZone = Utils.$('img_drop_zone');
        this.imgFileInput = Utils.$('img_file_input');
        this.imgPreview = Utils.$('img_preview');
        this.imgPreviewImg = Utils.$('img_preview_img');
        this.imgFileInfo = Utils.$('img_file_info');
        this.imgUrlInput = Utils.$('img_url');

        // Sound elements
        this.soundDropZone = Utils.$('sound_drop_zone');
        this.soundFileInput = Utils.$('sound_file_input');
        this.soundPreview = Utils.$('sound_preview');
        this.soundFileInfo = Utils.$('sound_file_info');
        this.soundUrlInput = Utils.$('sound_url');

        this.setupImageUpload();
        this.setupSoundUpload();
      },

      /*
       * Setup image upload handlers
      */
      setupImageUpload() {
        const self = this;

        // Preview on URL change
        ['input', 'change', 'paste'].forEach(event => {
          this.imgUrlInput.addEventListener(event, (e) => {
            const delay = event === 'paste' ? 10 : 0;
            setTimeout(() => self.updateImagePreview(e.target.value.trim()), delay);
          });
        });

        // Click to browse
        this.imgDropZone.addEventListener('click', (e) => {
          if (e.target.id !== 'img_file_input') {
            this.imgFileInput.click();
          }
        });

        // File input change
        this.imgFileInput.addEventListener('change', (e) => {
          if (e.target.files[0]) this.handleImageFile(e.target.files[0]);
        });

        // Drag and drop
        this.imgDropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          this.imgDropZone.style.borderColor = '#FF9800';
          this.imgDropZone.style.background = 'rgba(255, 152, 0, 0.1)';
        });

        this.imgDropZone.addEventListener('dragleave', (e) => {
          e.preventDefault();
          this.imgDropZone.style.borderColor = '#555';
          this.imgDropZone.style.background = 'rgba(40, 40, 40, 0.5)';
        });

        this.imgDropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          this.imgDropZone.style.borderColor = '#555';
          this.imgDropZone.style.background = 'rgba(40, 40, 40, 0.5)';

          const file = e.dataTransfer.files[0];
          if (file?.type.startsWith('image/')) {
            this.handleImageFile(file);
          } else {
            MessageSystem.show('img', 'Please drop an image file', 'error');
          }
        });
      },

      /*
       * Setup sound upload handlers
      */
      setupSoundUpload() {
        const self = this;

        // Preview on URL change
        ['input', 'change', 'paste'].forEach(event => {
          this.soundUrlInput.addEventListener(event, (e) => {
            const delay = event === 'paste' ? 10 : 0;
            setTimeout(() => self.updateAudioPreview(e.target.value.trim()), delay);
          });
        });

        // Click to browse
        this.soundDropZone.addEventListener('click', (e) => {
          if (e.target.id !== 'sound_file_input') {
            this.soundFileInput.click();
          }
        });

        // File input change
        this.soundFileInput.addEventListener('change', (e) => {
          if (e.target.files[0]) this.handleAudioFile(e.target.files[0]);
        });

        // Drag and drop
        this.soundDropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          this.soundDropZone.style.borderColor = '#FF9800';
          this.soundDropZone.style.background = 'rgba(255, 152, 0, 0.1)';
        });

        this.soundDropZone.addEventListener('dragleave', (e) => {
          e.preventDefault();
          this.soundDropZone.style.borderColor = '#555';
          this.soundDropZone.style.background = 'rgba(40, 40, 40, 0.5)';
        });

        this.soundDropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          this.soundDropZone.style.borderColor = '#555';
          this.soundDropZone.style.background = 'rgba(40, 40, 40, 0.5)';

          const file = e.dataTransfer.files[0];
          if (file?.type.startsWith('audio/')) {
            this.handleAudioFile(file);
          } else {
            MessageSystem.show('sound', 'Please drop an audio file', 'error');
          }
        });
      },

      /*
       * Update image preview
      */
      updateImagePreview(url) {
        if (!url) {
          this.imgPreview.style.display = 'none';
          this.imgUrlInput.style.borderColor = '';
          return;
        }

        const resolvedUrl = Utils.resolveGalleryUrl(url);
        const self = this;

        const img = new Image();
        img.onload = () => {
          self.imgPreviewImg.src = resolvedUrl;
          if (url.startsWith('gallery:')) {
            self.imgFileInfo.textContent = 'Gallery item';
          } else if (url.startsWith('data:')) {
            self.imgFileInfo.textContent = 'Base64 image';
          } else {
            self.imgFileInfo.textContent = url.split('/').pop() || 'Image preview';
          }
          self.imgPreview.style.display = 'block';
          self.imgUrlInput.style.borderColor = '#4CAF50';
        };
        img.onerror = () => {
          self.imgPreview.style.display = 'none';
          self.imgUrlInput.style.borderColor = '#f44336';
        };
        img.src = resolvedUrl;
      },

      /*
       * Update audio preview
      */
      updateAudioPreview(url) {
        if (!url) {
          this.soundPreview.style.display = 'none';
          this.soundUrlInput.style.borderColor = '';
          return;
        }

        const resolvedUrl = Utils.resolveGalleryUrl(url);
        const self = this;

        const audio = new Audio();
        audio.onloadedmetadata = () => {
          if (url.startsWith('gallery:')) {
            self.soundFileInfo.textContent = 'Gallery item';
          } else if (url.startsWith('data:')) {
            self.soundFileInfo.textContent = 'Base64 audio';
          } else {
            self.soundFileInfo.textContent = url.split('/').pop() || 'Audio file';
          }
          self.soundPreview.style.display = 'block';
          self.soundUrlInput.style.borderColor = '#4CAF50';
        };
        audio.onerror = () => {
          self.soundPreview.style.display = 'none';
          self.soundUrlInput.style.borderColor = '#f44336';
        };
        audio.src = resolvedUrl;
      },

      /*
       * Handle image file upload
      */
      handleImageFile(file) {
        if (!file.type.startsWith('image/')) {
          MessageSystem.show('img', 'Please select an image file', 'error');
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const galleryId = GalleryManager.addToGallery('image', dataUrl, file.name || 'image_' + Date.now(), 'image');
          
          Utils.$('img_url').value = `gallery:${galleryId}`;
          this.updateImagePreview(dataUrl);
          RealTimeUpdater.updateImage();
        };
        reader.readAsDataURL(file);
      },

      /*
       * Handle audio file upload
      */
      handleAudioFile(file) {
        if (!file.type.startsWith('audio/')) {
          MessageSystem.show('sound', 'Please select an audio file', 'error');
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const galleryId = GalleryManager.addToGallery('sound', dataUrl, file.name || 'sound_' + Date.now(), 'sound');
          
          Utils.$('sound_url').value = `gallery:${galleryId}`;
          this.updateAudioPreview(dataUrl);
          RealTimeUpdater.updateSound();
        };
        reader.readAsDataURL(file);
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FORM HANDLER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const FormHandler = {
      /*
       * Initialize all form handlers
      */
      init() {
        this.setupImageForm();
        this.setupMarkForm();
        this.setupSoundForm();
      },

      /*
       * Setup image form handlers
      */
      setupImageForm() {
        // Add/Update button
        Utils.$('img_add').addEventListener('click', () => {
          const name = Utils.$('img_name').value.trim();
          const url = Utils.$('img_url').value.trim();
          const xVal = Utils.$('img_x').value.trim();
          const yVal = Utils.$('img_y').value.trim();
          const appearScaleVal = Utils.$('img_appearScale').value.trim();
          const sizeVal = Utils.$('img_size').value.trim();
          const parentPath = Utils.$('img_parent').value;

          // Parse with defaults for empty fields
          const x = xVal === '' ? 0 : parseFloat(xVal);
          const y = yVal === '' ? 0 : parseFloat(yVal);
          const appearScale = appearScaleVal === '' ? 0 : parseFloat(appearScaleVal);
          const size = sizeVal === '' ? 1 : parseFloat(sizeVal);

          if (!url || isNaN(x) || isNaN(y) || isNaN(appearScale) || isNaN(size)) {
            MessageSystem.show('img', 'Please fill all required fields with valid values', 'error');
            return;
          }

          if (AppState.editingNodePath) {
            // Update existing node
            const node = Utils.getNodeByPath(AppState.editingNodePath);
            if (!node) {
              MessageSystem.show('img', 'Error: Node not found', 'error');
              return;
            }

            const updateChildren = Utils.$('img_update_children').checked;
            const { backupImageData } = AppState;
            const deltaX = x - backupImageData.x;
            const deltaY = y - backupImageData.y;
            const scaleRatio = size / backupImageData.size;

            // Update children if checkbox is checked
            if (updateChildren && node.children?.length && (deltaX !== 0 || deltaY !== 0 || scaleRatio !== 1)) {
              const updateChildrenRecursive = (children, parentX, parentY) => {
                children.forEach(child => {
                  const relativeX = child.x - parentX;
                  const relativeY = child.y - parentY;
                  child.x = x + relativeX * scaleRatio;
                  child.y = y + relativeY * scaleRatio;
                  child.size *= scaleRatio;
                  child.appearScale /= scaleRatio;
                  if (child.children?.length) {
                    updateChildrenRecursive(child.children, parentX, parentY);
                  }
                });
              };
              updateChildrenRecursive(node.children, backupImageData.x, backupImageData.y);
            }

            // Handle parent path change - move node to new parent
            const originalParentPath = backupImageData.parentPath || '';
            if (parentPath !== originalParentPath) {
              const oldPath = AppState.editingNodePath;
              
              // Find all marks that reference this image's old path
              const marksToUpdate = [];
              
              // Check node marks (within the node itself)
              const collectNodeMarks = (n, basePath) => {
                if (n.marks?.length) {
                  n.marks.forEach(mark => {
                    marksToUpdate.push({ mark, oldParentPath: basePath, isNodeMark: true });
                  });
                }
                if (n.children?.length) {
                  n.children.forEach((child, idx) => {
                    collectNodeMarks(child, basePath + ',' + idx);
                  });
                }
              };
              collectNodeMarks(node, oldPath);
              
              // Check general marks
              AppState.generalMarks.forEach(mark => {
                if (mark.parentPath === oldPath) {
                  marksToUpdate.push({ mark, oldParentPath: oldPath, isNodeMark: false });
                }
              });
              
              // Remove from original location
              Utils.deleteNodeByPath(oldPath);
              
              // Add to new parent and determine new path
              let newPath;
              if (parentPath) {
                const newParent = Utils.getNodeByPath(parentPath);
                if (newParent) {
                  if (!newParent.children) newParent.children = [];
                  const newIndex = newParent.children.length;
                  newParent.children.push(node);
                  newPath = parentPath + ',' + newIndex;
                }
              } else {
                const newIndex = AppState.config.length;
                AppState.config.push(node);
                newPath = String(newIndex);
              }
              
              // Update marks to reference new path
              if (newPath) {
                marksToUpdate.forEach(({ mark, oldParentPath, isNodeMark }) => {
                  if (!isNodeMark && mark.parentPath) {
                    // For general marks, update parentPath
                    if (oldParentPath === oldPath) {
                      mark.parentPath = newPath;
                    } else {
                      // Update descendant paths
                      const relativePath = oldParentPath.substring(oldPath.length);
                      mark.parentPath = newPath + relativePath;
                    }
                  }
                  // Node marks automatically move with their parent, no path update needed
                });
              }
            }

            ImageSystem.loadImages(node);
            MarkSystem.rebuildMarks();
            CanvasManager.render();
            EditModeController.populateNodeSelects();

            // Clear form
            EditModeController.resetImageForm();
            MessageSystem.show('img', 'Image updated successfully!', 'success');
            DataManager.triggerAutoSave();
          } else {
            // Add new node
            const newNode = {
              src: url,
              x, y,
              appearScale,
              size,
              children: []
            };

            if (name) newNode.name = name;

            // If URL is a data URL, add to gallery
            if (url.startsWith('data:image/')) {
              const galleryId = GalleryManager.addToGallery('image', url, name || 'image_' + Date.now(), 'image');
              newNode.src = `gallery:${galleryId}`;
            }

            // Add to parent or root
            if (parentPath) {
              const parent = Utils.getNodeByPath(parentPath);
              if (parent) {
                if (!parent.children) parent.children = [];
                parent.children.push(newNode);
              }
            } else {
              AppState.config.push(newNode);
            }

            ImageSystem.loadImages(newNode);
            MarkSystem.rebuildMarks();
            CanvasManager.render();
            EditModeController.populateNodeSelects();
            EditModeController.updateImageDeleteList();

            // Clear form
            Utils.$('img_name').value = '';
            Utils.$('img_url').value = '';
            Utils.$('img_x').value = '';
            Utils.$('img_y').value = '';
            Utils.$('img_appearScale').value = '0';
            Utils.$('img_size').value = '1';
            Utils.$('img_parent').value = '';
            Utils.$('img_preview').style.display = 'none';
            Utils.$('img_file_input').value = '';
            Utils.$('img_url').style.borderColor = '';

            MessageSystem.show('img', 'Image added successfully!', 'success');
            DataManager.triggerAutoSave();
          }
        });

        // Clear button
        Utils.$('img_clear').addEventListener('click', () => {
          if (AppState.editingNodePath && AppState.backupImageData) {
            const node = Utils.getNodeByPath(AppState.editingNodePath);
            if (node) {
              if (AppState.backupImageData.name) {
                node.name = AppState.backupImageData.name;
              } else {
                delete node.name;
              }
              node.src = AppState.backupImageData.src;
              node.x = AppState.backupImageData.x;
              node.y = AppState.backupImageData.y;
              node.appearScale = AppState.backupImageData.appearScale;
              node.size = AppState.backupImageData.size;
              ImageSystem.loadImages(node);
              CanvasManager.render();
            }
          }

          EditModeController.resetImageForm();
          MessageSystem.hide('img');
        });
      },

      /*
       * Setup mark form handlers
      */
      setupMarkForm() {
        // Add/Update button
        Utils.$('mark_add').addEventListener('click', () => {
          const markType = Utils.$('mark_type').value;
          const markTypeEmoji = Utils.$('mark_markType').value;
          const markDescription = Utils.$('mark_description').value.trim();

          if (!markType) {
            MessageSystem.show('mark', 'Please select a type', 'error');
            return;
          }

          if (AppState.editingMarkData) {
            // Update existing
            MarkSystem.rebuildMarks();
            EditModeController.updateAllDeleteLists();
            CanvasManager.render();
            EditModeController.resetMarkForm();
            MessageSystem.show('mark', 'Mark updated successfully!', 'success');
            DataManager.triggerAutoSave();
          } else {
            // Add new
            if (markType === 'node') {
              const nodePath = Utils.$('mark_node').value;
              if (!nodePath) {
                MessageSystem.show('mark', 'Please select a node', 'error');
                return;
              }
              const node = Utils.getNodeByPath(nodePath);
              if (node) {
                node.mark = markDescription;
                if (markTypeEmoji) node.markType = markTypeEmoji;
              }
            } else {
              const xVal = Utils.$('mark_x').value.trim();
              const yVal = Utils.$('mark_y').value.trim();
              const parentPath = Utils.$('mark_parent').value;
              const name = Utils.$('mark_name').value.trim();

              // Parse with defaults for empty fields
              const x = xVal === '' ? 0 : parseFloat(xVal);
              const y = yVal === '' ? 0 : parseFloat(yVal);

              if (isNaN(x) || isNaN(y)) {
                MessageSystem.show('mark', 'Please enter valid coordinates', 'error');
                return;
              }

              const newMark = { x, y, mark: markDescription };
              if (name) newMark.name = name;
              if (parentPath) newMark.parentPath = parentPath;
              if (markTypeEmoji) newMark.markType = markTypeEmoji;
              AppState.generalMarks.push(newMark);
            }

            MarkSystem.rebuildMarks();
            EditModeController.updateAllDeleteLists();
            CanvasManager.render();
            EditModeController.resetMarkForm();
            MessageSystem.show('mark', 'Mark added successfully!', 'success');
            DataManager.triggerAutoSave();
          }
        });

        // Clear button
        Utils.$('mark_clear').addEventListener('click', () => {
          if (AppState.editingMarkData && AppState.backupMarkData) {
            if (AppState.editingMarkData.type === 'node') {
              const node = Utils.getNodeByPath(AppState.editingMarkData.path);
              if (node) {
                if (AppState.backupMarkData.markType) {
                  node.markType = AppState.backupMarkData.markType;
                } else {
                  delete node.markType;
                }
                node.mark = AppState.backupMarkData.mark;
              }
            } else {
              const mark = AppState.generalMarks[AppState.editingMarkData.index];
              if (mark) {
                Object.assign(mark, {
                  x: AppState.backupMarkData.x,
                  y: AppState.backupMarkData.y,
                  name: AppState.backupMarkData.name,
                  mark: AppState.backupMarkData.mark
                });
                if (AppState.backupMarkData.parentPath) {
                  mark.parentPath = AppState.backupMarkData.parentPath;
                } else {
                  delete mark.parentPath;
                }
                if (AppState.backupMarkData.markType) {
                  mark.markType = AppState.backupMarkData.markType;
                } else {
                  delete mark.markType;
                }
              }
            }
            MarkSystem.rebuildMarks();
            CanvasManager.render();
          }

          EditModeController.resetMarkForm();
          MessageSystem.hide('mark');
        });
      },

      /*
       * Setup sound form handlers
      */
      setupSoundForm() {
        // Add/Update button
        Utils.$('sound_add').addEventListener('click', () => {
          const name = Utils.$('sound_name').value.trim();
          const url = Utils.$('sound_url').value.trim();
          const x1Val = Utils.$('sound_x1').value.trim();
          const y1Val = Utils.$('sound_y1').value.trim();
          const x2Val = Utils.$('sound_x2').value.trim();
          const y2Val = Utils.$('sound_y2').value.trim();
          const minScaleVal = Utils.$('sound_minScale').value.trim();
          const maxScaleStr = Utils.$('sound_maxScale').value.trim();

          // Parse with defaults for empty fields
          const x1 = x1Val === '' ? 0 : parseFloat(x1Val);
          const y1 = y1Val === '' ? 0 : parseFloat(y1Val);
          const x2 = x2Val === '' ? 0 : parseFloat(x2Val);
          const y2 = y2Val === '' ? 0 : parseFloat(y2Val);
          const minScale = minScaleVal === '' ? 0 : parseFloat(minScaleVal);

          if (!url || isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2) || isNaN(minScale)) {
            MessageSystem.show('sound', 'Please fill all required fields with valid values', 'error');
            return;
          }

          if (AppState.editingSoundIndex !== null) {
            // Update existing
            EditModeController.updateSoundDeleteList();
            CanvasManager.render();
            EditModeController.resetSoundForm();
            MessageSystem.show('sound', 'Sound updated successfully!', 'success');
            DataManager.triggerAutoSave();
          } else {
            // Add new
            const audioSrc = Utils.resolveGalleryUrl(url);
            const newSound = {
              src: url,
              x1, y1, x2, y2,
              minScale,
              audio: new Audio(audioSrc),
              playing: false
            };

            if (name) newSound.name = name;

            // If URL is data URL, add to gallery
            if (url.startsWith('data:audio/')) {
              const galleryId = GalleryManager.addToGallery('sound', url, name || 'sound_' + Date.now(), 'sound');
              newSound.src = `gallery:${galleryId}`;
            }

            if (maxScaleStr) {
              const maxScale = parseFloat(maxScaleStr);
              if (!isNaN(maxScale)) newSound.maxScale = maxScale;
            }

            newSound.audio.loop = true;
            newSound.audio.volume = 1;

            AppState.sounds.push(newSound);
            CanvasManager.render();
            EditModeController.updateSoundDeleteList();

            // Clear form
            Utils.$('sound_name').value = '';
            Utils.$('sound_url').value = '';
            Utils.$('sound_x1').value = '';
            Utils.$('sound_y1').value = '';
            Utils.$('sound_x2').value = '';
            Utils.$('sound_y2').value = '';
            Utils.$('sound_minScale').value = '0';
            Utils.$('sound_maxScale').value = '';

            MessageSystem.show('sound', 'Sound added successfully!', 'success');
            DataManager.triggerAutoSave();
          }
        });

        // Clear button
        Utils.$('sound_clear').addEventListener('click', () => {
          if (AppState.editingSoundIndex !== null && AppState.backupSoundData) {
            const sound = AppState.sounds[AppState.editingSoundIndex];
            if (sound) {
              if (sound.playing) sound.audio.pause();
              
              Object.assign(sound, {
                src: AppState.backupSoundData.src,
                x1: AppState.backupSoundData.x1,
                y1: AppState.backupSoundData.y1,
                x2: AppState.backupSoundData.x2,
                y2: AppState.backupSoundData.y2,
                minScale: AppState.backupSoundData.minScale
              });

              if (AppState.backupSoundData.name) {
                sound.name = AppState.backupSoundData.name;
              } else {
                delete sound.name;
              }
              if (AppState.backupSoundData.maxScale) {
                sound.maxScale = AppState.backupSoundData.maxScale;
              } else {
                delete sound.maxScale;
              }

              const audioSrc = Utils.resolveGalleryUrl(AppState.backupSoundData.src);
              sound.audio = new Audio(audioSrc);
              sound.audio.loop = true;
              sound.audio.volume = 1;
              sound.playing = false;

              CanvasManager.render();
            }
          }

          EditModeController.resetSoundForm();
          MessageSystem.hide('sound');
        });
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GALLERY MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const GalleryManager = {
      currentType: 'image',
      selectMode: false,
      manageMode: false,
      currentFolder: { image: 'image', sound: 'sound' },

      /*
       * Open gallery modal
      */
      open(type = 'image', manageMode = false) {
        this.currentType = type;
        this.selectMode = !manageMode;
        this.manageMode = manageMode;
        Utils.$('galleryModal').classList.add('active');
        
        // Show/hide tabs container based on mode
        const galleryTabsContainer = document.querySelector('.gallery-tabs');
        if (galleryTabsContainer) {
          if (manageMode) {
            galleryTabsContainer.classList.remove('hidden');
          } else {
            galleryTabsContainer.classList.add('hidden');
          }
        }
        
        this.switchTab(type);
        this.updateBreadcrumb();
        this.render();
        this.initDropZone();
      },

      /*
       * Close gallery modal
      */
      close() {
        Utils.$('galleryModal').classList.remove('active');
        this.selectMode = false;
        this.manageMode = false;
      },

      /*
       * Switch gallery tab
      */
      switchTab(type) {
        this.currentType = type;
        Utils.$$('.gallery-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.type === type);
        });
        this.updateBreadcrumb();
        this.render();
      },

      /*
       * Navigate to folder
      */
      navigateToFolder(path) {
        this.currentFolder[this.currentType] = path;
        this.updateBreadcrumb();
        this.render();
      },

      /*
       * Update breadcrumb
      */
      updateBreadcrumb() {
        const breadcrumb = Utils.$('galleryBreadcrumb');
        const currentFolder = this.currentFolder[this.currentType];
        const parts = currentFolder.split('/').filter(p => p);
        
        breadcrumb.innerHTML = '';
        
        // Root
        const rootSpan = document.createElement('span');
        rootSpan.className = 'gallery-breadcrumb-item';
        rootSpan.textContent = this.currentType === 'image' ? 'ğŸ–¼ï¸ Images' : 'ğŸµ Sounds';
        rootSpan.onclick = () => this.navigateToFolder(this.currentType);
        this.makeDroppable(rootSpan, this.currentType);
        breadcrumb.appendChild(rootSpan);
        
        // Parts
        let currentPath = this.currentType;
        parts.forEach((part, index) => {
          if (index === 0 && (part === 'image' || part === 'sound')) return;
          
          const separator = document.createElement('span');
          separator.className = 'gallery-breadcrumb-separator';
          separator.textContent = '/';
          breadcrumb.appendChild(separator);
          
          currentPath += '/' + part;
          const partSpan = document.createElement('span');
          partSpan.className = 'gallery-breadcrumb-item';
          partSpan.textContent = part;
          const pathToNavigate = currentPath;
          partSpan.onclick = () => this.navigateToFolder(pathToNavigate);
          this.makeDroppable(partSpan, pathToNavigate);
          breadcrumb.appendChild(partSpan);
        });
      },

      /*
       * Make element droppable
      */
      makeDroppable(element, targetFolder) {
        element.ondragover = (e) => {
          e.preventDefault();
          e.stopPropagation();
          element.classList.add('drag-over');
        };
        element.ondragleave = (e) => {
          e.stopPropagation();
          element.classList.remove('drag-over');
        };
        element.ondrop = (e) => {
          e.preventDefault();
          e.stopPropagation();
          element.classList.remove('drag-over');
          const itemId = e.dataTransfer.getData('text/plain');
          if (itemId) this.moveItemToFolder(itemId, targetFolder);
        };
      },

      /*
       * Initialize drop zone
      */
      initDropZone() {
        const content = Utils.$('galleryContent');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          content.addEventListener(eventName, (e) => {
            const isInternalDrag = e.dataTransfer.types.includes('text/plain') && !e.dataTransfer.types.includes('Files');
            if (!isInternalDrag) {
              e.preventDefault();
              e.stopPropagation();
            }
          }, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
          content.addEventListener(eventName, (e) => {
            const isInternalDrag = e.dataTransfer.types.includes('text/plain') && !e.dataTransfer.types.includes('Files');
            if (!isInternalDrag && e.dataTransfer.types.includes('Files')) {
              content.classList.add('drag-over');
            }
          }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
          content.addEventListener(eventName, (e) => {
            const isInternalDrag = e.dataTransfer.types.includes('text/plain') && !e.dataTransfer.types.includes('Files');
            if (!isInternalDrag) content.classList.remove('drag-over');
          }, false);
        });

        content.addEventListener('drop', (e) => {
          const dt = e.dataTransfer;
          const isInternalDrag = dt.types.includes('text/plain') && !dt.types.includes('Files');
          if (isInternalDrag) return;
          
          const files = Array.from(dt.files);
          if (files.length > 0) this.handleDroppedFiles(files);
        }, false);
      },

      /*
       * Handle dropped files
      */
      handleDroppedFiles(files) {
        const validFiles = files.filter(file => {
          if (this.currentType === 'image') return file.type.startsWith('image/');
          if (this.currentType === 'sound') return file.type.startsWith('audio/');
          return false;
        });

        if (validFiles.length === 0) {
          alert('No valid files selected');
          return;
        }

        let processed = 0;
        const currentFolder = this.currentFolder[this.currentType];
        
        validFiles.forEach(file => {
          const reader = new FileReader();
          reader.onload = (event) => {
            this.addToGallery(this.currentType, event.target.result, file.name, currentFolder);
            processed++;
            if (processed === validFiles.length) this.render();
          };
          reader.onerror = () => {
            processed++;
            if (processed === validFiles.length) this.render();
          };
          reader.readAsDataURL(file);
        });
      },

      /*
       * Count references to gallery item
      */
      countReferences(itemId) {
        let count = 0;
        
        const checkNode = (node) => {
          if (node.src === `gallery:${itemId}`) count++;
          if (node.children) node.children.forEach(checkNode);
        };
        AppState.config.forEach(checkNode);
        
        AppState.sounds.forEach(sound => {
          if (sound.src === `gallery:${itemId}`) count++;
        });
        
        return count;
      },

      /*
       * Render gallery
      */
      render() {
        const searchTerm = Utils.$('gallerySearch').value.toLowerCase();
        const sortValue = Utils.$('gallerySort').value;
        const content = Utils.$('galleryContent');
        const currentFolder = this.currentFolder[this.currentType];

        // Get folders
        let folders = AppState.gallery.filter(item => {
          if (item.type !== 'folder') return false;
          if (item.content !== this.currentType) return false;
          if (!item.folder.startsWith(this.currentType + '/')) return false;
          const parentPath = item.folder.substring(0, item.folder.lastIndexOf('/'));
          return parentPath === currentFolder;
        });

        // Get items
        let items = AppState.gallery.filter(item => {
          if (item.type === 'folder') return false;
          if (item.type !== this.currentType) return false;
          const itemFolder = item.folder || this.currentType;
          return itemFolder === currentFolder;
        });

        // Search filter
        if (searchTerm) {
          folders = folders.filter(f => f.name.toLowerCase().includes(searchTerm));
          items = items.filter(i => i.name.toLowerCase().includes(searchTerm));
        }

        // Sort
        const sortFn = (a, b) => {
          switch (sortValue) {
            case 'name-asc': return a.name.localeCompare(b.name);
            case 'name-desc': return b.name.localeCompare(a.name);
            case 'date-desc': return new Date(b.date) - new Date(a.date);
            case 'date-asc': return new Date(a.date) - new Date(b.date);
            default: return a.name.localeCompare(b.name);
          }
        };
        folders.sort(sortFn);
        items.sort(sortFn);

        if (folders.length === 0 && items.length === 0) {
          content.innerHTML = '<div class="gallery-empty">No items found</div>';
          return;
        }

        const grid = document.createElement('div');
        grid.className = 'gallery-grid';

        // Render folders
        folders.forEach(folder => {
          const itemDiv = this.createFolderElement(folder);
          grid.appendChild(itemDiv);
        });

        // Render items
        items.forEach(item => {
          const itemDiv = this.createItemElement(item);
          grid.appendChild(itemDiv);
        });

        content.innerHTML = '';
        content.appendChild(grid);
      },

      /*
       * Create folder element
      */
      createFolderElement(folder) {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'gallery-item folder-item';
        itemDiv.onclick = () => this.navigateToFolder(folder.folder);
        this.makeDroppable(itemDiv, folder.folder);

        const preview = document.createElement('div');
        preview.className = 'gallery-item-preview folder';
        preview.textContent = 'ğŸ“';

        const nameDiv = document.createElement('div');
        nameDiv.className = 'gallery-item-name';
        nameDiv.textContent = folder.name;
        nameDiv.ondblclick = (e) => {
          e.stopPropagation();
          this.renameItem(folder.id, nameDiv);
        };

        const itemCount = AppState.gallery.filter(item => {
          if (item.id === folder.id) return false;
          return item.folder === folder.folder || (item.folder && item.folder.startsWith(folder.folder + '/'));
        }).length;

        const info = document.createElement('div');
        info.className = 'gallery-item-info';
        info.innerHTML = `
          <span>${new Date(folder.date).toLocaleDateString()}</span>
          <span class="gallery-item-refs ${itemCount === 0 ? 'zero' : ''}">${itemCount} item${itemCount !== 1 ? 's' : ''}</span>
        `;

        if (itemCount === 0) {
          const deleteBtn = document.createElement('div');
          deleteBtn.className = 'gallery-item-delete can-delete';
          deleteBtn.textContent = 'Ã—';
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            this.deleteFolder(folder.id);
          };
          itemDiv.appendChild(deleteBtn);
        }

        itemDiv.appendChild(preview);
        itemDiv.appendChild(nameDiv);
        itemDiv.appendChild(info);
        return itemDiv;
      },

      /*
       * Create item element
      */
      createItemElement(item) {
        const refCount = this.countReferences(item.id);
        const canDelete = refCount === 0;

        const itemDiv = document.createElement('div');
        itemDiv.className = 'gallery-item';
        itemDiv.onclick = () => this.selectItem(item);
        itemDiv.draggable = true;
        itemDiv.ondragstart = (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', item.id);
          itemDiv.classList.add('dragging');
        };
        itemDiv.ondragend = () => itemDiv.classList.remove('dragging');

        const preview = document.createElement('div');
        preview.className = 'gallery-item-preview';
        if (item.type === 'image') {
          const img = document.createElement('img');
          img.src = item.content;
          img.draggable = false;
          preview.appendChild(img);
        } else {
          preview.classList.add('sound');
          preview.textContent = 'ğŸµ';
        }

        const nameDiv = document.createElement('div');
        nameDiv.className = 'gallery-item-name';
        nameDiv.textContent = item.name;
        nameDiv.ondblclick = (e) => {
          e.stopPropagation();
          this.renameItem(item.id, nameDiv);
        };

        const info = document.createElement('div');
        info.className = 'gallery-item-info';
        info.innerHTML = `
          <span>${new Date(item.date).toLocaleDateString()}</span>
          <span class="gallery-item-refs ${canDelete ? 'zero' : ''}">${refCount} ref${refCount !== 1 ? 's' : ''}</span>
        `;

        const updateBtn = document.createElement('div');
        updateBtn.className = 'gallery-item-update';
        updateBtn.textContent = 'â†»';
        updateBtn.title = 'Update content';
        updateBtn.onclick = (e) => {
          e.stopPropagation();
          this.updateItem(item.id);
        };
        itemDiv.appendChild(updateBtn);

        if (canDelete) {
          const deleteBtn = document.createElement('div');
          deleteBtn.className = 'gallery-item-delete can-delete';
          deleteBtn.textContent = 'Ã—';
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            this.deleteItem(item.id);
          };
          itemDiv.appendChild(deleteBtn);
        }

        itemDiv.appendChild(preview);
        itemDiv.appendChild(nameDiv);
        itemDiv.appendChild(info);
        return itemDiv;
      },

      /*
       * Select item from gallery
      */
      selectItem(item) {
        // Cannot select in manage mode
        if (this.manageMode || !this.selectMode || item.type === 'folder') return;

        if (this.currentType === 'image') {
          Utils.$('img_url').value = `gallery:${item.id}`;
          FileUploadHandler.updateImagePreview(`gallery:${item.id}`);
          if (AppState.editingNodePath) RealTimeUpdater.updateImage();
        } else {
          Utils.$('sound_url').value = `gallery:${item.id}`;
          FileUploadHandler.updateAudioPreview(`gallery:${item.id}`);
          if (AppState.editingSoundIndex !== null) RealTimeUpdater.updateSound();
        }

        this.close();
      },

      /*
       * Move item to folder
      */
      moveItemToFolder(itemId, folderPath) {
        const item = AppState.gallery.find(i => i.id === itemId);
        if (!item || item.type === 'folder') return;
        item.folder = folderPath;
        DataManager.triggerAutoSave();
        this.render();
      },

      /*
       * Create new folder
      */
      createFolder() {
        const folderName = prompt('Enter folder name:');
        if (!folderName) return;

        if (folderName.includes('/') || folderName.includes('\\')) {
          alert('Folder name cannot contain / or \\');
          return;
        }

        const currentFolder = this.currentFolder[this.currentType];
        const folderPath = currentFolder === this.currentType
          ? this.currentType + '/' + folderName
          : currentFolder + '/' + folderName;

        if (AppState.gallery.some(item => item.type === 'folder' && item.folder === folderPath && item.content === this.currentType)) {
          alert('Folder already exists');
          return;
        }

        AppState.gallery.push({
          id: Utils.generateGalleryId(),
          type: 'folder',
          content: this.currentType,
          name: folderName,
          date: new Date().toISOString(),
          folder: folderPath
        });

        DataManager.triggerAutoSave();
        this.render();
      },

      /*
       * Delete folder
      */
      deleteFolder(folderId) {
        const folder = AppState.gallery.find(i => i.id === folderId);
        if (!folder) return;

        const hasContents = AppState.gallery.some(item => {
          if (item.id === folder.id) return false;
          return item.folder === folder.folder || (item.folder && item.folder.startsWith(folder.folder + '/'));
        });

        if (hasContents) {
          alert('Cannot delete: Folder is not empty');
          return;
        }

        if (confirm(`Delete folder "${folder.name}"?`)) {
          AppState.gallery = AppState.gallery.filter(i => i.id !== folderId);
          this.render();
          DataManager.triggerAutoSave();
        }
      },

      /*
       * Rename item
      */
      renameItem(itemId, nameDiv) {
        const item = AppState.gallery.find(i => i.id === itemId);
        if (!item) return;

        const input = document.createElement('input');
        input.type = 'text';
        input.value = item.name;
        input.onclick = (e) => e.stopPropagation();
        input.onblur = () => {
          const newName = input.value.trim();
          if (newName && newName !== item.name) {
            item.name = newName;
            DataManager.triggerAutoSave();
          }
          this.render();
        };
        input.onkeydown = (e) => {
          if (e.key === 'Enter') input.blur();
          else if (e.key === 'Escape') this.render();
          e.stopPropagation();
        };

        nameDiv.innerHTML = '';
        nameDiv.appendChild(input);
        input.focus();
        input.select();
      },

      /*
       * Update item content
      */
      updateItem(itemId) {
        const item = AppState.gallery.find(i => i.id === itemId);
        if (!item) return;

        const input = document.createElement('input');
        input.type = 'file';
        input.accept = item.type === 'image' ? 'image/*' : 'audio/*';

        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (event) => {
            item.content = event.target.result;
            item.name = file.name || item.name;
            item.updated = new Date().toISOString();
            item.folder = item.type;

            // Reload all using this item
            if (item.type === 'image') {
              const reloadNode = (node) => {
                if (node.src === `gallery:${itemId}`) ImageSystem.loadImages(node);
                if (node.children) node.children.forEach(reloadNode);
              };
              AppState.config.forEach(reloadNode);
            } else {
              AppState.sounds.forEach(sound => {
                if (sound.src === `gallery:${itemId}`) {
                  if (sound.playing) sound.audio.pause();
                  sound.audio = new Audio(event.target.result);
                  sound.audio.loop = true;
                  sound.audio.volume = 1;
                  sound.playing = false;
                }
              });
            }

            this.render();
            CanvasManager.render();
            DataManager.triggerAutoSave();
          };
          reader.readAsDataURL(file);
        };

        input.click();
      },

      /*
       * Delete item
      */
      deleteItem(itemId) {
        const refCount = this.countReferences(itemId);
        if (refCount > 0) {
          alert(`Cannot delete: This item is used in ${refCount} place${refCount !== 1 ? 's' : ''}`);
          return;
        }

        const item = AppState.gallery.find(i => i.id === itemId);
        if (!item) return;

        if (confirm(`Delete "${item.name}"?`)) {
          AppState.gallery = AppState.gallery.filter(i => i.id !== itemId);
          this.render();
          DataManager.triggerAutoSave();
        }
      },

      /*
       * Upload to gallery
      */
      upload() {
        const input = Utils.$('gallery_file_input');
        input.accept = this.currentType === 'image' ? 'image/*' : 'audio/*';

        input.onchange = (e) => {
          const files = Array.from(e.target.files);
          if (files.length === 0) return;

          const validFiles = files.filter(file => {
            if (this.currentType === 'image') return file.type.startsWith('image/');
            if (this.currentType === 'sound') return file.type.startsWith('audio/');
            return false;
          });

          if (validFiles.length === 0) {
            alert('No valid files selected');
            return;
          }

          let processed = 0;
          const currentFolder = this.currentFolder[this.currentType];
          
          validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onload = (event) => {
              this.addToGallery(this.currentType, event.target.result, file.name, currentFolder);
              processed++;
              if (processed === validFiles.length) this.render();
            };
            reader.onerror = () => {
              processed++;
              if (processed === validFiles.length) this.render();
            };
            reader.readAsDataURL(file);
          });

          e.target.value = '';
        };

        input.click();
      },

      /*
       * Add item to gallery
      */
      addToGallery(type, content, name, folder = null) {
        // Check if content already exists
        const existing = AppState.gallery.find(item => item.content === content);
        if (existing) return existing.id;

        const item = {
          id: Utils.generateGalleryId(),
          type,
          content,
          name: name || `${type}_${Date.now()}`,
          date: new Date().toISOString(),
          folder: folder || this.currentFolder[type] || type
        };

        AppState.gallery.push(item);
        DataManager.triggerAutoSave();
        return item.id;
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DRAG & DROP CONTROLLER (List Reordering)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const DragDropController = {
      draggedElement: null,
      draggedIndex: null,
      draggedData: null,
      autoScrollInterval: null,
      lastDragY: null,
      dragThrottleTimeout: null,
      cachedValidItems: null,
      currentListType: null,
      initializedLists: new Set(), // Track which lists have been set up

      /*
       * Setup drag and drop on list (only once per list)
      */
      setupDragAndDrop(listElement, listType) {
        // Prevent duplicate setup - only initialize once per list
        const listId = listType + '_delete_list';
        if (this.initializedLists.has(listId)) {
          return;
        }
        this.initializedLists.add(listId);

        listElement.addEventListener('dragover', (e) => {
          e.preventDefault();
          if (!this.draggedElement || !this.draggedData) return;

          // Throttle dragover processing - only process if Y changed significantly
          const currentY = e.clientY;
          if (this.lastDragY !== null && Math.abs(currentY - this.lastDragY) < 5) {
            return;
          }
          this.lastDragY = currentY;

          const draggable = this.draggedElement;
          if (!draggable) return;

          // Use cached valid items for finding insertion point
          const afterElement = this.getDragAfterElementCached(listElement, currentY);

          if (afterElement == null) {
            // Dragging to the end - insert after last valid sibling
            const lastValidItem = this.getLastValidSiblingCached();
            if (lastValidItem) {
              lastValidItem.parentNode.insertBefore(draggable, lastValidItem.nextSibling);
            }
          } else {
            // Insert before the afterElement
            listElement.insertBefore(draggable, afterElement);
          }

          // Auto-scroll
          const rect = listElement.getBoundingClientRect();
          const scrollThreshold = 50;
          if (currentY < rect.top + scrollThreshold) {
            this.startAutoScroll(listElement, -5);
          } else if (currentY > rect.bottom - scrollThreshold) {
            this.startAutoScroll(listElement, 5);
          } else {
            this.stopAutoScroll();
          }
        });

        listElement.addEventListener('dragleave', (e) => {
          if (e.target === listElement) this.stopAutoScroll();
        });

        listElement.addEventListener('drop', (e) => {
          e.preventDefault();
          this.stopAutoScroll();
          this.handleDrop(listElement, listType);
        });
      },

      /*
       * Make item draggable
      */
      makeItemDraggable(item, index, data, listType) {
        const searchInput = Utils.$(`${listType}_search`);
        const isSearching = searchInput?.value.trim() !== '';

        if (isSearching) {
          item.classList.remove('draggable');
          item.draggable = false;
          const handle = item.querySelector('.delete-item-drag-handle');
          if (handle) handle.style.display = 'none';
          return;
        }

        item.classList.add('draggable');
        item.draggable = true;

        if (!item.querySelector('.delete-item-drag-handle')) {
          const handle = document.createElement('div');
          handle.className = 'delete-item-drag-handle';
          handle.innerHTML = 'â‹®â‹®';
          item.insertBefore(handle, item.firstChild);
        }

        item.addEventListener('dragstart', (e) => {
          this.draggedElement = item;
          this.draggedIndex = index;
          this.draggedData = data;
          this.currentListType = listType;
          this.lastDragY = null;
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';

          // Mark valid/invalid zones and cache valid items
          const listElement = item.closest('.delete-list');
          if (listElement && this.draggedData) {
            const draggedPath = this.draggedData.path ?? '';
            const draggedDepth = this.draggedData.depth ?? 0;
            const draggedParentPath = this.draggedData.parentPath ?? '';
            const allItems = listElement.querySelectorAll('.delete-item');
            
            // Build cache of valid items
            this.cachedValidItems = [];
            
            allItems.forEach(otherItem => {
              if (otherItem === item) return;

              const otherItemPath = otherItem.getAttribute('data-path') ?? '';
              if (otherItemPath.startsWith(draggedPath + ',')) {
                otherItem.style.display = 'none';
                return;
              }

              const otherDepth = parseInt(otherItem.getAttribute('data-depth') ?? '0');
              const otherParentPath = otherItem.getAttribute('data-parent-path') ?? '';

              // Check if same level (valid drop zone)
              let isValid = false;
              if (this.draggedData?.depth !== undefined) {
                isValid = otherDepth === draggedDepth && otherParentPath === draggedParentPath;
              } else if (this.draggedData?.isGeneral !== undefined) {
                isValid = otherItem.getAttribute('data-type') === 'general';
              } else {
                isValid = true; // sounds - all are valid
              }

              if (isValid) {
                otherItem.classList.add('drag-valid-zone');
                this.cachedValidItems.push(otherItem);
              } else {
                otherItem.classList.add('drag-invalid-zone');
              }
            });
          }
        });

        item.addEventListener('dragend', () => {
          item.classList.remove('dragging');
          const listElement = item.closest('.delete-list');
          if (listElement) {
            listElement.querySelectorAll('.delete-item').forEach(otherItem => {
              otherItem.classList.remove('drag-valid-zone', 'drag-invalid-zone');
              otherItem.style.display = '';
            });
          }
          // Clear all state and cache
          this.draggedElement = null;
          this.draggedIndex = null;
          this.draggedData = null;
          this.cachedValidItems = null;
          this.currentListType = null;
          this.lastDragY = null;
          this.stopAutoScroll();
        });
      },

      /*
       * Get element after which to insert (using cache)
      */
      getDragAfterElementCached(container, y) {
        // Use cached valid items if available
        const validItems = this.cachedValidItems || [];

        return validItems.reduce((closest, child) => {
          if (child.classList.contains('dragging')) return closest;
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
          }
          return closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
      },

      /*
       * Get last valid sibling (using cache)
      */
      getLastValidSiblingCached() {
        const validItems = this.cachedValidItems || [];
        // Filter out the dragging item
        const filtered = validItems.filter(item => !item.classList.contains('dragging'));
        return filtered[filtered.length - 1] || null;
      },

      /*
       * Start auto-scroll
      */
      startAutoScroll(element, speed) {
        this.stopAutoScroll();
        this.autoScrollInterval = setInterval(() => {
          element.scrollTop += speed;
        }, 20);
      },

      /*
       * Stop auto-scroll
      */
      stopAutoScroll() {
        if (this.autoScrollInterval) {
          clearInterval(this.autoScrollInterval);
          this.autoScrollInterval = null;
        }
      },

      /*
       * Handle drop
      */
      handleDrop(listElement, listType) {
        if (!this.draggedElement || this.draggedIndex === null) return;

        const draggedDepth = this.draggedData?.depth ?? 0;
        const draggedParentPath = this.draggedData?.parentPath ?? '';
        
        // Query the current DOM state to find same-level items
        const allItems = [...listElement.querySelectorAll('.delete-item')];
        
        let sameLevelItems;
        if (listType === 'img') {
          sameLevelItems = allItems.filter(item =>
            parseInt(item.getAttribute('data-depth') ?? '0') === draggedDepth &&
            (item.getAttribute('data-parent-path') ?? '') === draggedParentPath
          );
        } else if (listType === 'mark') {
          sameLevelItems = allItems.filter(item => item.getAttribute('data-type') === 'general');
        } else {
          sameLevelItems = allItems; // All sounds are at same level
        }

        const currentIndex = this.draggedIndex;
        
        // Calculate the new index based on current DOM position among same-level items
        const newIndex = sameLevelItems.indexOf(this.draggedElement);

        if (newIndex === -1 || newIndex === currentIndex) {
          // No change - just refresh the specific list
          this.updateSpecificList(listType);
          return;
        }

        // Reorder data
        if (listType === 'img') {
          let parentArray;
          if (draggedDepth === 0) {
            parentArray = AppState.config;
          } else {
            const parentPathArray = draggedParentPath.split(',').filter(p => p).map(Number);
            let parent = AppState.config[parentPathArray[0]];
            for (let i = 1; i < parentPathArray.length; i++) {
              parent = parent.children[parentPathArray[i]];
            }
            parentArray = parent.children;
          }

          const [removed] = parentArray.splice(currentIndex, 1);
          parentArray.splice(newIndex, 0, removed);
          MarkSystem.rebuildMarks();
          CanvasManager.render();
          EditModeController.populateNodeSelects();
        } else if (listType === 'mark') {
          if (this.draggedData?.isGeneral) {
            const [removed] = AppState.generalMarks.splice(currentIndex, 1);
            AppState.generalMarks.splice(newIndex, 0, removed);
            MarkSystem.rebuildMarks();
            CanvasManager.render();
          }
        } else if (listType === 'sound') {
          const [removed] = AppState.sounds.splice(currentIndex, 1);
          AppState.sounds.splice(newIndex, 0, removed);
          SoundSystem.stopAll();
          CanvasManager.render();
        }

        // Only update the specific list that changed, not all lists
        this.updateSpecificList(listType);
        DataManager.triggerAutoSave();
      },

      /*
       * Update only the specific list that was modified
      */
      updateSpecificList(listType) {
        if (listType === 'img') {
          EditModeController.updateImageDeleteList();
        } else if (listType === 'mark') {
          EditModeController.updateMarkDeleteList();
        } else if (listType === 'sound') {
          EditModeController.updateSoundDeleteList();
        }
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INITIALIZATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Warn before leaving with unsaved changes
    window.addEventListener('beforeunload', (e) => {
      if (AppState.hasUnsavedChanges) {
        e.preventDefault();
        e.returnValue = '';
        return '';
      }
    });

    // Main initialization
    window.onload = async () => {
      const loadingScreen = Utils.$('loadingScreen');

      // Initialize canvas
      CanvasManager.init();
      
      // Load data
      await DataManager.loadFromJSON();
      
      // Initialize controllers
      NavigationController.init();
      EditModeController.init();
      SearchController.init();
      RealTimeUpdater.init();
      
      // Initial render
      CanvasManager.render();
      EditModeController.updateAllDeleteLists();
      
      // Hide loading screen
      setTimeout(() => {
        loadingScreen.classList.add('hidden');
      }, 300);
      
      // Re-render as images load
      let renderCount = 0;
      const renderInterval = setInterval(() => {
        CanvasManager.render();
        renderCount++;
        if (renderCount >= 10) {
          clearInterval(renderInterval);
        }
      }, 200);
    };

    // Expose functions for inline HTML handlers
    window.openGallery = (type, manageMode) => GalleryManager.open(type, manageMode);
    window.closeGallery = () => GalleryManager.close();
    window.switchGalleryTab = (type) => GalleryManager.switchTab(type);
    window.createFolder = () => GalleryManager.createFolder();
    window.uploadToGallery = () => GalleryManager.upload();
  </script>
</body>
</html>